"""UniFi Network Controller MCP Server (auto-generated).

Generated from controller version 10.0.162.
Total tools: ~285

DO NOT EDIT THIS FILE. All changes must be made in the generator.
"""

from __future__ import annotations

import json
import os
import re
from typing import Any

import httpx
from fastmcp import FastMCP

mcp = FastMCP("UniFi Network Controller")

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

UNIFI_HOST = os.environ.get("UNIFI_HOST", "localhost")
UNIFI_PORT = int(os.environ.get("UNIFI_PORT", "8443"))
UNIFI_USERNAME = os.environ.get("UNIFI_USERNAME", "admin")
UNIFI_PASSWORD = os.environ.get("UNIFI_PASSWORD", "")
UNIFI_SITE = os.environ.get("UNIFI_SITE", "default")
UNIFI_VERIFY_SSL = os.environ.get("UNIFI_VERIFY_SSL", "false").lower() == "true"
UNIFI_MODULES = set(
    m.strip() for m in os.environ.get("UNIFI_MODULES", "v1,v2").split(",") if m.strip()
)
UNIFI_READ_ONLY = os.environ.get("UNIFI_READ_ONLY", "false").lower() == "true"
UNIFI_REDACT_SECRETS = os.environ.get("UNIFI_REDACT_SECRETS", "true").lower() != "false"


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------


class UniFiClient:
    """Handles authentication, session cookies, and CSRF tokens."""

    def __init__(self) -> None:
        self._client = httpx.AsyncClient(
            base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
            verify=UNIFI_VERIFY_SSL,
            timeout=30.0,
        )
        self._csrf_token: str | None = None
        self._logged_in = False

    async def login(self) -> None:
        resp = await self._client.post(
            "/api/login",
            json={"username": UNIFI_USERNAME, "password": UNIFI_PASSWORD},
        )
        resp.raise_for_status()
        # Extract CSRF token from cookies or response
        self._csrf_token = resp.cookies.get("csrf_token") or resp.headers.get("x-csrf-token")
        self._logged_in = True

    async def logout(self) -> None:
        if self._logged_in:
            try:
                await self._client.post("/api/logout")
            except Exception:
                pass
            self._logged_in = False

    async def _ensure_logged_in(self) -> None:
        if not self._logged_in:
            await self.login()

    async def request(
        self,
        method: str,
        path: str,
        json_data: dict | None = None,
        site: str | None = None,
    ) -> dict | list:
        """Make an authenticated API request. Auto-relogins on 401."""
        await self._ensure_logged_in()

        # Replace {site} placeholder in path
        effective_site = site or UNIFI_SITE
        full_path = path.replace("{site}", effective_site)

        # Ensure path starts with /
        if not full_path.startswith("/"):
            full_path = f"/api/s/{effective_site}/{full_path}"

        headers = {}
        if self._csrf_token:
            headers["x-csrf-token"] = self._csrf_token

        try:
            resp = await self._client.request(
                method, full_path, json=json_data, headers=headers,
            )
        except httpx.ConnectError:
            raise RuntimeError(
                f"Connection failed: cannot reach UniFi controller at "
                f"{UNIFI_HOST}:{UNIFI_PORT}. Check UNIFI_HOST and UNIFI_PORT."
            )
        except httpx.TimeoutException:
            raise RuntimeError(
                f"Request timed out: {method} {full_path}. "
                f"The controller at {UNIFI_HOST}:{UNIFI_PORT} may be overloaded or unreachable."
            )

        # Auto-relogin on 401
        if resp.status_code == 401:
            await self.login()
            if self._csrf_token:
                headers["x-csrf-token"] = self._csrf_token
            resp = await self._client.request(
                method, full_path, json=json_data, headers=headers,
            )

        if resp.status_code == 403:
            raise RuntimeError(
                f"Authentication failed (403 Forbidden): {method} {full_path}. "
                f"Check UNIFI_USERNAME and UNIFI_PASSWORD."
            )

        # Parse response body before raising for status â€” UniFi often
        # returns useful error details in the JSON body for 400/404/500.
        try:
            data = resp.json()
        except Exception:
            # Non-JSON response (empty body, HTML error page, etc.)
            if resp.status_code >= 400:
                raise RuntimeError(
                    f"HTTP {resp.status_code} on {method} {full_path} "
                    f"(non-JSON response, {len(resp.content)} bytes). "
                    f"Controller may still be starting up."
                )
            resp.raise_for_status()
            return []

        # v1 API envelope
        if isinstance(data, dict) and "meta" in data:
            if data["meta"].get("rc") != "ok":
                msg = data["meta"].get("msg", "Unknown error")
                raise RuntimeError(f"UniFi API error on {method} {full_path}: {msg}")
            return data.get("data", [])

        # For non-envelope errors (v2 API, raw error objects)
        if resp.status_code >= 400:
            if isinstance(data, dict):
                # Try common error fields
                msg = data.get("message") or data.get("error") or data.get("msg") or str(data)
            else:
                msg = str(data)
            raise RuntimeError(f"HTTP {resp.status_code} on {method} {full_path}: {msg}")

        return data

    async def close(self) -> None:
        await self.logout()
        await self._client.aclose()


# Singleton client
_client = UniFiClient()


async def _get_client() -> UniFiClient:
    return _client


# ---------------------------------------------------------------------------
# Helper: secret redaction
# ---------------------------------------------------------------------------

_REDACT_FIELDS = frozenset({
    "x_passphrase", "x_iapp_key", "x_password", "x_shadow",
    "x_private_key", "x_certificate_pem", "x_certificate_arn",
    "x_api_token", "x_mgmt_key", "x_secret", "x_psk",
    "x_mesh_psk", "x_element_psk",
})
_REDACT_SUBSTRINGS = ("password", "passphrase", "secret", "preshared_key")


def _redact_secrets(obj: Any) -> Any:
    """Recursively replace sensitive field values with '<redacted>'."""
    if isinstance(obj, dict):
        return {
            k: "<redacted>" if (k in _REDACT_FIELDS or any(s in k.lower() for s in _REDACT_SUBSTRINGS)) else _redact_secrets(v)
            for k, v in obj.items()
        }
    if isinstance(obj, list):
        return [_redact_secrets(item) for item in obj]
    return obj


# ---------------------------------------------------------------------------
# Helper: format response
# ---------------------------------------------------------------------------

def _format_response(data: Any, summary: str | None = None) -> dict:
    """Format API response data as structured dict for tool output."""
    if UNIFI_REDACT_SECRETS:
        data = _redact_secrets(data)
    result: dict[str, Any] = {}
    if summary:
        result["summary"] = summary
    if isinstance(data, list):
        result["count"] = len(data)
        result["data"] = data
    elif data is not None:
        result["data"] = data
    return result


# ---------------------------------------------------------------------------
# Helper: pagination and field selection
# ---------------------------------------------------------------------------

def _paginate_and_filter(data: list, limit: int, offset: int, fields: str) -> list:
    """Apply offset, limit, and field selection to a list of records."""
    if offset:
        data = data[offset:]
    if limit:
        data = data[:limit]
    if fields:
        field_set = {f.strip() for f in fields.split(",")}
        field_set.add("_id")  # always include _id for reference
        data = [
            {k: v for k, v in item.items() if k in field_set}
            for item in data if isinstance(item, dict)
        ]
    return data


_MAC_RE = re.compile(r"^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$")


def _validate_mac(mac: str) -> str | None:
    """Return an error message if MAC format is invalid, else None."""
    if not _MAC_RE.match(mac):
        return f"Invalid MAC address format: '{mac}'. Expected format: XX:XX:XX:XX:XX:XX (hex pairs separated by colons)."
    return None


# ===========================================================================
# Error Reporting Tool (always-on)
# ===========================================================================


@mcp.tool()
async def unifi_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: dict[str, Any],
    notes: str = "",
) -> dict:
    """Report an unexpected UniFi MCP tool error by composing a GitHub issue command.

    This tool does NOT make any HTTP calls. It returns a ready-to-paste
    `gh issue create` command that the user can review and run to file a bug report.

    Args:
        tool_name: The MCP tool that produced the error (e.g. unifi_create_network).
        error_message: The error message or response body returned by the tool.
        parameters_used: The parameters that were passed to the failing tool call.
        notes: Any additional context about what you were trying to accomplish.
    """
    import json as _json

    params_block = _json.dumps(parameters_used, indent=2, default=str)
    notes_section = f"\n\n## Notes\n\n{notes}" if notes else ""

    body = (
        f"## Tool\n\n`{tool_name}`\n\n"
        f"## Error\n\n```\n{error_message}\n```\n\n"
        f"## Parameters\n\n```json\n{params_block}\n```\n\n"
        f"## Repro Steps\n\n"
        f"1. Call `{tool_name}` with the parameters above\n"
        f"2. Observe the error response"
        f"{notes_section}"
    )

    escaped_body = body.replace("'", "'\\''")
    escaped_title = f"Bug: {tool_name} returns unexpected error".replace("'", "'\\''")

    return (
        f"Run this command to file the issue:\n\n"
        f"gh issue create --repo abl030/unifi-mcp "
        f"--label bug --label mcp-reported "
        f"--title '{escaped_title}' "
        f"--body '{escaped_body}'"
    )



if "device" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: device
    # ===========================================================================

    # --- Device_config (read-only) ---

    @mcp.tool()
    async def unifi_list_device_configs(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all device_configs.

        Returns device_configs from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/device", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} device_configs")



    # --- Element (read-only) ---

    @mcp.tool()
    async def unifi_list_elements(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all elements.

        Returns elements from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/element", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} elements")



    # --- Virtual_device (read-only) ---

    @mcp.tool()
    async def unifi_list_virtual_devices(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all virtual_devices.

        Returns virtual_devices from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/virtualdevice", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} virtual_devices")



    @mcp.tool()
    async def unifi_list_devices(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List devices statistics.

        Note: also POST with macs filter

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/device", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} devices records")



    @mcp.tool()
    async def unifi_list_devices_basic(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List devices_basic statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/device-basic", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} devices_basic records")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_adopt_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'adopt' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "adopt_device", "cmd": "adopt"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "adopt"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed adopt")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_restart_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'restart' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "restart_device", "cmd": "restart"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "restart"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed restart")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_force_provision_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'force-provision' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "force_provision_device", "cmd": "force-provision"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "force-provision"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed force-provision")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_power_cycle_port(
            mac: str,
            port_idx: int,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'power-cycle' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                port_idx: port_idx parameter (int).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "power_cycle_port", "cmd": "power-cycle"}
                preview["mac"] = mac
                preview["port_idx"] = port_idx
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "power-cycle"}
            payload["mac"] = mac
            payload["port_idx"] = port_idx
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed power-cycle")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_run_speedtest(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'speedtest' via devmgr.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "run_speedtest", "cmd": "speedtest"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "speedtest"}
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed speedtest")



    @mcp.tool()
    async def unifi_get_speedtest_status(
        site: str = "",
    ) -> dict:
        """Execute 'speedtest-status' via devmgr.

            site: Site name override (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        payload: dict[str, Any] = {"cmd": "speedtest-status"}
        client = await _get_client()
        result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
        return _format_response(result, "Executed speedtest-status")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_locate_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'set-locate' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "locate_device", "cmd": "set-locate"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "set-locate"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed set-locate")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_unlocate_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'unset-locate' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "unlocate_device", "cmd": "unset-locate"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "unset-locate"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed unset-locate")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_upgrade_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'upgrade' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "upgrade_device", "cmd": "upgrade"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "upgrade"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed upgrade")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_upgrade_device_external(
            mac: str,
            url: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'upgrade-external' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                url: url parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "upgrade_device_external", "cmd": "upgrade-external"}
                preview["mac"] = mac
                preview["url"] = url
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "upgrade-external"}
            payload["mac"] = mac
            payload["url"] = url
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed upgrade-external")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_migrate_device(
            mac: str,
            inform_url: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'migrate' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                inform_url: inform_url parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "migrate_device", "cmd": "migrate"}
                preview["mac"] = mac
                preview["inform_url"] = inform_url
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "migrate"}
            payload["mac"] = mac
            payload["inform_url"] = inform_url
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed migrate")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_cancel_migrate_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'cancel-migrate' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "cancel_migrate_device", "cmd": "cancel-migrate"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "cancel-migrate"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed cancel-migrate")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_spectrum_scan(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'spectrum-scan' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "spectrum_scan", "cmd": "spectrum-scan"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "spectrum-scan"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed spectrum-scan")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_rename_device(
            mac: str,
            name: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'rename' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                name: name parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "rename_device", "cmd": "rename"}
                preview["mac"] = mac
                preview["name"] = name
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "rename"}
            payload["mac"] = mac
            payload["name"] = name
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed rename")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_led_override_device(
            mac: str,
            led_override: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'led-override' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                led_override: led_override parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "led_override_device", "cmd": "led-override"}
                preview["mac"] = mac
                preview["led_override"] = led_override
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "led-override"}
            payload["mac"] = mac
            payload["led_override"] = led_override
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed led-override")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_disable_ap(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'disable-ap' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "disable_ap", "cmd": "disable-ap"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "disable-ap"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed disable-ap")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_upgrade_all_devices(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'upgrade-all-devices' via devmgr.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "upgrade_all_devices", "cmd": "upgrade-all-devices"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "upgrade-all-devices"}
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed upgrade-all-devices")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_advanced_adopt_device(
            mac: str,
            url: str,
            key: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'advanced-adopt' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                url: url parameter (str).
            Args:
                key: key parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "advanced_adopt_device", "cmd": "advanced-adopt"}
                preview["mac"] = mac
                preview["url"] = url
                preview["key"] = key
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "advanced-adopt"}
            payload["mac"] = mac
            payload["url"] = url
            payload["key"] = key
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed advanced-adopt")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_restart_http_portal(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'restart-http-portal' via devmgr.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "restart_http_portal", "cmd": "restart-http-portal"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "restart-http-portal"}
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed restart-http-portal")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_enable_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'enable' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "enable_device", "cmd": "enable"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "enable"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed enable")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_disable_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'disable' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "disable_device", "cmd": "disable"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "disable"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed disable")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_cable_test(
            mac: str,
            port_idx: int,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'cable-test' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                port_idx: port_idx parameter (int).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "cable_test", "cmd": "cable-test"}
                preview["mac"] = mac
                preview["port_idx"] = port_idx
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "cable-test"}
            payload["mac"] = mac
            payload["port_idx"] = port_idx
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed cable-test")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_set_inform_device(
            mac: str,
            inform_url: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'set-inform' via devmgr.

            Args:
                mac: mac parameter (str).
            Args:
                inform_url: inform_url parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "set_inform_device", "cmd": "set-inform"}
                preview["mac"] = mac
                preview["inform_url"] = inform_url
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "set-inform"}
            payload["mac"] = mac
            payload["inform_url"] = inform_url
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed set-inform")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_move_device(
            mac: str,
            target_site: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'move-device' via sitemgr.

            Args:
                mac: mac parameter (str).
            Args:
                target_site: Target site for the command (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "move_device", "cmd": "move-device"}
                preview["mac"] = mac
                preview["site"] = target_site
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "move-device"}
            payload["mac"] = mac
            payload["site"] = target_site
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed move-device")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_delete_device(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'delete-device' via sitemgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "delete_device", "cmd": "delete-device"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "delete-device"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed delete-device")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_reboot_cloudkey(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'reboot-cloudkey' via system.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "reboot_cloudkey", "cmd": "reboot-cloudkey"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/system): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "reboot-cloudkey"}
            client = await _get_client()
            result = await client.request("POST", "cmd/system", json_data=payload, site=site or None)
            return _format_response(result, "Executed reboot-cloudkey")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_element_adoption(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'element-adoption' via system.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "element_adoption", "cmd": "element-adoption"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/system): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "element-adoption"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/system", json_data=payload, site=site or None)
            return _format_response(result, "Executed element-adoption")



    # ===========================================================================
    # Special: Port Override Helper
    # ===========================================================================

    if not UNIFI_READ_ONLY:
        @mcp.tool()
        async def unifi_set_port_override(
            device_id: str,
            port_idx: int,
            portconf_id: str = "",
            name: str = "",
            native_networkconf_id: str = "",
            forward: str = "",
            poe_mode: str = "",
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Set port override on a device (switch port configuration).

            This updates a specific port on a UniFi switch device.

            Args:
                device_id: The _id of the device.
                port_idx: Port number (1-based).
                portconf_id: Port profile ID to apply (from rest/portconf).
                name: Custom port name.
                native_networkconf_id: Network ID for native VLAN.
                forward: Forward mode ('all', 'customize', 'disabled').
                poe_mode: PoE mode ('auto', 'off', 'pasv24', 'passthrough').
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            override: dict[str, Any] = {"port_idx": port_idx}
            if portconf_id:
                override["portconf_id"] = portconf_id
            if name:
                override["name"] = name
            if native_networkconf_id:
                override["native_networkconf_id"] = native_networkconf_id
            if forward:
                override["forward"] = forward
            if poe_mode:
                override["poe_mode"] = poe_mode

            if not confirm:
                return _format_response(
                    {"action": "set_port_override", "device_id": device_id, "override": override},
                    "DRY RUN (PUT rest/device/{device_id}): Set confirm=True to execute.",
                )

            client = await _get_client()
            # First get current device to preserve existing overrides
            device_data = await client.request("GET", f"rest/device/{device_id}", site=site or None)
            if isinstance(device_data, list) and device_data:
                device_data = device_data[0]

            existing_overrides = []
            if isinstance(device_data, dict):
                existing_overrides = device_data.get("port_overrides", [])

            # Replace or append override for this port_idx
            new_overrides = [o for o in existing_overrides if o.get("port_idx") != port_idx]
            new_overrides.append(override)

            result = await client.request(
                "PUT",
                f"rest/device/{device_id}",
                json_data={"port_overrides": new_overrides},
                site=site or None,
            )
            return _format_response(result, f"Set port override on port {port_idx}")


if "client" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: client
    # ===========================================================================

    # --- User CRUD ---

    @mcp.tool()
    async def unifi_list_users(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all users.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/user", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} users")


    @mcp.tool()
    async def unifi_get_user(id: str, site: str = "") -> dict:
        """Get a single user by ID.

        Args:
            id: The _id of the user.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/user/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_user(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new user.

            Args:
                data: User configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Note: To remove a user, use unifi_forget_client with the user's MAC address. REST DELETE is not supported for the user resource.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_user", "data": data},
                    "DRY RUN (POST rest/user): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/user", json_data=data, site=site or None)
            return _format_response(result, "Created user")


        @mcp.tool()
        async def unifi_update_user(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing user.

            Args:
                id: The _id of the user to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Note: To remove a user, use unifi_forget_client with the user's MAC address. REST DELETE is not supported for the user resource.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_user", "id": id, "data": data},
                    "DRY RUN (PUT rest/user/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/user/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated user")



    @mcp.tool()
    async def unifi_list_all_users(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all_users statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/alluser", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} all_users records")



    @mcp.tool()
    async def unifi_list_guests(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List guests statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/guest", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} guests records")



    @mcp.tool()
    async def unifi_list_sessions(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List sessions statistics.

        Note: requires POST with {"type":"all","start":0,"end":9999999999}

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/session", json_data={'type': 'all', 'start': 0, 'end': 9999999999}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} sessions records")



    @mcp.tool()
    async def unifi_list_clients(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List clients statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/sta", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} clients records")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_block_client(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'block-sta' via stamgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "block_client", "cmd": "block-sta"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "block-sta"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed block-sta")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_unblock_client(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'unblock-sta' via stamgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "unblock_client", "cmd": "unblock-sta"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "unblock-sta"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed unblock-sta")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_kick_client(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'kick-sta' via stamgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "kick_client", "cmd": "kick-sta"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "kick-sta"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed kick-sta")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_forget_client(
            macs: list,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'forget-sta' via stamgr.

            Args:
                macs: macs parameter (list).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "forget_client", "cmd": "forget-sta"}
                preview["macs"] = macs
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "forget-sta"}
            payload["macs"] = macs
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed forget-sta")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_unauthorize_guest(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'unauthorize-guest' via stamgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "unauthorize_guest", "cmd": "unauthorize-guest"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "unauthorize-guest"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed unauthorize-guest")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_authorize_guest(
            mac: str,
            minutes: int,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'authorize-guest' via stamgr.

            Args:
                mac: mac parameter (str).
            Args:
                minutes: minutes parameter (int).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "authorize_guest", "cmd": "authorize-guest"}
                preview["mac"] = mac
                preview["minutes"] = minutes
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "authorize-guest"}
            payload["mac"] = mac
            payload["minutes"] = minutes
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed authorize-guest")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_reconnect_client(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'reconnect-sta' via stamgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "reconnect_client", "cmd": "reconnect-sta"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stamgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "reconnect-sta"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/stamgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed reconnect-sta")



if "client" in UNIFI_MODULES or "v2" in UNIFI_MODULES:
    
    # --- v2: Active_client ---

    @mcp.tool()
    async def unifi_list_active_clients(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all active_clients (v2 API).

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/clients/active".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} active_clients")
        return _format_response(data)



    # --- v2: Client_history ---

    @mcp.tool()
    async def unifi_list_clients_history(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all clients_history (v2 API).

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/clients/history".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} clients_history")
        return _format_response(data)



if "wifi" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: wifi
    # ===========================================================================

    # --- Channel_plan (read-only) ---

    @mcp.tool()
    async def unifi_list_channel_plans(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all channel_plans.

        Returns channel_plans from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/channelplan", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} channel_plans")



    # --- Wlan CRUD ---

    @mcp.tool()
    async def unifi_list_wlans(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all wlans.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/wlanconf", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} wlans")


    @mcp.tool()
    async def unifi_get_wlan(id: str, site: str = "") -> dict:
        """Get a single wlan by ID.

        Args:
            id: The _id of the wlan.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/wlanconf/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_wlan(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new wlan.

            Args:
                data: Wlan configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Requires a network (networkconf_id from unifi_list_networks) and at least one adopted AP.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_wlan", "data": data},
                    "DRY RUN (POST rest/wlanconf): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/wlanconf", json_data=data, site=site or None)
            return _format_response(result, "Created wlan")


        @mcp.tool()
        async def unifi_update_wlan(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing wlan.

            Args:
                id: The _id of the wlan to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Requires a network (networkconf_id from unifi_list_networks) and at least one adopted AP.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_wlan", "id": id, "data": data},
                    "DRY RUN (PUT rest/wlanconf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/wlanconf/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated wlan")


        @mcp.tool()
        async def unifi_delete_wlan(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a wlan.

            Args:
                id: The _id of the wlan to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_wlan", "id": id},
                    "DRY RUN (DELETE rest/wlanconf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/wlanconf/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted wlan")



    # --- Wlan_group CRUD ---

    @mcp.tool()
    async def unifi_list_wlan_groups(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all wlan_groups.

        Key fields: name (str)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/wlangroup", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} wlan_groups")


    @mcp.tool()
    async def unifi_get_wlan_group(id: str, site: str = "") -> dict:
        """Get a single wlan_group by ID.

        Args:
            id: The _id of the wlan_group.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/wlangroup/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_wlan_group(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new wlan_group.

            Args:
                data: Wlan_group configuration.
                    Fields: name (str)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_wlan_group", "data": data},
                    "DRY RUN (POST rest/wlangroup): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/wlangroup", json_data=data, site=site or None)
            return _format_response(result, "Created wlan_group")


        @mcp.tool()
        async def unifi_update_wlan_group(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing wlan_group.

            Args:
                id: The _id of the wlan_group to update.
                data: Fields to update.
                    Fields: name (str)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_wlan_group", "id": id, "data": data},
                    "DRY RUN (PUT rest/wlangroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/wlangroup/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated wlan_group")


        @mcp.tool()
        async def unifi_delete_wlan_group(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a wlan_group.

            Args:
                id: The _id of the wlan_group to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_wlan_group", "id": id},
                    "DRY RUN (DELETE rest/wlangroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/wlangroup/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted wlan_group")



    @mcp.tool()
    async def unifi_list_country_codes(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List country_codes statistics.

        Key fields: code, key, name

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/ccode", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} country_codes records")



    @mcp.tool()
    async def unifi_list_current_channels(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List current_channels statistics.

        Key fields: afc, channels_6e, channels_6e_160, channels_6e_320, channels_6e_40

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/current-channel", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} current_channels records")



    @mcp.tool()
    async def unifi_list_spectrum_scans(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List spectrum_scans statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/spectrum-scan", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} spectrum_scans records")



if "wifi" in UNIFI_MODULES or "v2" in UNIFI_MODULES:
    
    # --- v2: Ap_group ---

    @mcp.tool()
    async def unifi_list_ap_groups(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all ap_groups (v2 API).

        Key fields: device_macs (list), for_wlanconf (bool), name (str)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/apgroups".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} ap_groups")
        return _format_response(data)



if "network" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: network
    # ===========================================================================

    # --- Dns_record CRUD ---

    @mcp.tool()
    async def unifi_list_dns_records(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all dns_records.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dnsrecord", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dns_records")


    @mcp.tool()
    async def unifi_get_dns_record(id: str, site: str = "") -> dict:
        """Get a single dns_record by ID.

        Args:
            id: The _id of the dns_record.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dnsrecord/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_dns_record(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new dns_record.

            Args:
                data: Dns_record configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_dns_record", "data": data},
                    "DRY RUN (POST rest/dnsrecord): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/dnsrecord", json_data=data, site=site or None)
            return _format_response(result, "Created dns_record")


        @mcp.tool()
        async def unifi_update_dns_record(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing dns_record.

            Args:
                id: The _id of the dns_record to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_dns_record", "id": id, "data": data},
                    "DRY RUN (PUT rest/dnsrecord/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/dnsrecord/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated dns_record")


        @mcp.tool()
        async def unifi_delete_dns_record(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a dns_record.

            Args:
                id: The _id of the dns_record to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_dns_record", "id": id},
                    "DRY RUN (DELETE rest/dnsrecord/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/dnsrecord/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted dns_record")



    # --- Network CRUD ---

    @mcp.tool()
    async def unifi_list_networks(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all networks.

        Key fields: ipv6_interface_type (str: "none"), ipv6_ra_priority (str: "high"), ipv6_setting_preference (str: "auto"), networkgroup (str: "LAN"), purpose (str: "corporate"), auto_scale_enabled (bool), dhcpd_enabled (bool), dhcpd_start (str)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/networkconf", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} networks")


    @mcp.tool()
    async def unifi_get_network(id: str, site: str = "") -> dict:
        """Get a single network by ID.

        Args:
            id: The _id of the network.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/networkconf/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_network(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new network.

            Args:
                data: Network configuration.
                    Fields: ipv6_interface_type (str: "none"), ipv6_ra_priority (str: "high"), ipv6_setting_preference (str: "auto"), networkgroup (str: "LAN"), purpose (str: "corporate"), auto_scale_enabled (bool), dhcpd_enabled (bool), dhcpd_start (str), dhcpd_stop (str), dhcpdv6_dns_auto (bool)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Use this network's _id as native_networkconf_id in port profiles or networkconf_id in WLANs.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_network", "data": data},
                    "DRY RUN (POST rest/networkconf): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/networkconf", json_data=data, site=site or None)
            return _format_response(result, "Created network")


        @mcp.tool()
        async def unifi_update_network(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing network.

            Args:
                id: The _id of the network to update.
                data: Fields to update.
                    Fields: ipv6_interface_type (str: "none"), ipv6_ra_priority (str: "high"), ipv6_setting_preference (str: "auto"), networkgroup (str: "LAN"), purpose (str: "corporate"), auto_scale_enabled (bool), dhcpd_enabled (bool), dhcpd_start (str), dhcpd_stop (str), dhcpdv6_dns_auto (bool)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Use this network's _id as native_networkconf_id in port profiles or networkconf_id in WLANs.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_network", "id": id, "data": data},
                    "DRY RUN (PUT rest/networkconf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/networkconf/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated network")


        @mcp.tool()
        async def unifi_delete_network(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a network.

            Args:
                id: The _id of the network to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_network", "id": id},
                    "DRY RUN (DELETE rest/networkconf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/networkconf/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted network")



    # --- Port_profile CRUD ---

    @mcp.tool()
    async def unifi_list_port_profiles(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all port_profiles.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/portconf", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} port_profiles")


    @mcp.tool()
    async def unifi_get_port_profile(id: str, site: str = "") -> dict:
        """Get a single port_profile by ID.

        Args:
            id: The _id of the port_profile.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/portconf/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_port_profile(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new port_profile.

            Args:
                data: Port_profile configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Apply this profile to switch ports via unifi_set_port_override with portconf_id.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_port_profile", "data": data},
                    "DRY RUN (POST rest/portconf): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/portconf", json_data=data, site=site or None)
            return _format_response(result, "Created port_profile")


        @mcp.tool()
        async def unifi_update_port_profile(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing port_profile.

            Args:
                id: The _id of the port_profile to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Apply this profile to switch ports via unifi_set_port_override with portconf_id.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_port_profile", "id": id, "data": data},
                    "DRY RUN (PUT rest/portconf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/portconf/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated port_profile")


        @mcp.tool()
        async def unifi_delete_port_profile(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a port_profile.

            Args:
                id: The _id of the port_profile to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_port_profile", "id": id},
                    "DRY RUN (DELETE rest/portconf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/portconf/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted port_profile")



if "firewall" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: firewall
    # ===========================================================================

    # --- Dhcp_option CRUD ---

    @mcp.tool()
    async def unifi_list_dhcp_options(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all dhcp_options.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dhcpoption", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dhcp_options")


    @mcp.tool()
    async def unifi_get_dhcp_option(id: str, site: str = "") -> dict:
        """Get a single dhcp_option by ID.

        Args:
            id: The _id of the dhcp_option.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dhcpoption/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_dhcp_option(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new dhcp_option.

            Args:
                data: Dhcp_option configuration.
                    Required: name (str), code (int, DHCP option number 7-254 excluding reserved: 15,42,43,44,51,66,67,252), value (str). Note: May require a DHCP-enabled network with gateway device.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_dhcp_option", "data": data},
                    "DRY RUN (POST rest/dhcpoption): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/dhcpoption", json_data=data, site=site or None)
            return _format_response(result, "Created dhcp_option")


        @mcp.tool()
        async def unifi_update_dhcp_option(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing dhcp_option.

            Args:
                id: The _id of the dhcp_option to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_dhcp_option", "id": id, "data": data},
                    "DRY RUN (PUT rest/dhcpoption/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/dhcpoption/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated dhcp_option")


        @mcp.tool()
        async def unifi_delete_dhcp_option(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a dhcp_option.

            Args:
                id: The _id of the dhcp_option to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_dhcp_option", "id": id},
                    "DRY RUN (DELETE rest/dhcpoption/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/dhcpoption/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted dhcp_option")



    # --- Dynamic_dns CRUD ---

    @mcp.tool()
    async def unifi_list_dynamic_dns_entries(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all dynamic_dns_entries.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dynamicdns", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dynamic_dns_entries")


    @mcp.tool()
    async def unifi_get_dynamic_dns(id: str, site: str = "") -> dict:
        """Get a single dynamic_dns by ID.

        Args:
            id: The _id of the dynamic_dns.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dynamicdns/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_dynamic_dns(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new dynamic_dns.

            Args:
                data: Dynamic_dns configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_dynamic_dns", "data": data},
                    "DRY RUN (POST rest/dynamicdns): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/dynamicdns", json_data=data, site=site or None)
            return _format_response(result, "Created dynamic_dns")


        @mcp.tool()
        async def unifi_update_dynamic_dns(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing dynamic_dns.

            Args:
                id: The _id of the dynamic_dns to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_dynamic_dns", "id": id, "data": data},
                    "DRY RUN (PUT rest/dynamicdns/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/dynamicdns/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated dynamic_dns")


        @mcp.tool()
        async def unifi_delete_dynamic_dns(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a dynamic_dns.

            Args:
                id: The _id of the dynamic_dns to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_dynamic_dns", "id": id},
                    "DRY RUN (DELETE rest/dynamicdns/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/dynamicdns/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted dynamic_dns")



    # --- Firewall_group CRUD ---

    @mcp.tool()
    async def unifi_list_firewall_groups(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all firewall_groups.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/firewallgroup", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} firewall_groups")


    @mcp.tool()
    async def unifi_get_firewall_group(id: str, site: str = "") -> dict:
        """Get a single firewall_group by ID.

        Args:
            id: The _id of the firewall_group.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/firewallgroup/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_firewall_group(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new firewall_group.

            Args:
                data: Firewall_group configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Reference this group's _id in src_firewallgroup_ids or dst_firewallgroup_ids when creating firewall rules.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_firewall_group", "data": data},
                    "DRY RUN (POST rest/firewallgroup): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/firewallgroup", json_data=data, site=site or None)
            return _format_response(result, "Created firewall_group")


        @mcp.tool()
        async def unifi_update_firewall_group(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing firewall_group.

            Args:
                id: The _id of the firewall_group to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Reference this group's _id in src_firewallgroup_ids or dst_firewallgroup_ids when creating firewall rules.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_firewall_group", "id": id, "data": data},
                    "DRY RUN (PUT rest/firewallgroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/firewallgroup/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated firewall_group")


        @mcp.tool()
        async def unifi_delete_firewall_group(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a firewall_group.

            Args:
                id: The _id of the firewall_group to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_firewall_group", "id": id},
                    "DRY RUN (DELETE rest/firewallgroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/firewallgroup/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted firewall_group")



    # --- Firewall_rule CRUD ---

    @mcp.tool()
    async def unifi_list_firewall_rules(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all firewall_rules.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/firewallrule", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} firewall_rules")


    @mcp.tool()
    async def unifi_get_firewall_rule(id: str, site: str = "") -> dict:
        """Get a single firewall_rule by ID.

        Args:
            id: The _id of the firewall_rule.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/firewallrule/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_firewall_rule(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new firewall_rule.

            Args:
                data: Firewall_rule configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Create firewall groups first (unifi_create_firewall_group) to use in src/dst_firewallgroup_ids.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_firewall_rule", "data": data},
                    "DRY RUN (POST rest/firewallrule): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/firewallrule", json_data=data, site=site or None)
            return _format_response(result, "Created firewall_rule")


        @mcp.tool()
        async def unifi_update_firewall_rule(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing firewall_rule.

            Args:
                id: The _id of the firewall_rule to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Create firewall groups first (unifi_create_firewall_group) to use in src/dst_firewallgroup_ids.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_firewall_rule", "id": id, "data": data},
                    "DRY RUN (PUT rest/firewallrule/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/firewallrule/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated firewall_rule")


        @mcp.tool()
        async def unifi_delete_firewall_rule(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a firewall_rule.

            Args:
                id: The _id of the firewall_rule to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_firewall_rule", "id": id},
                    "DRY RUN (DELETE rest/firewallrule/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/firewallrule/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted firewall_rule")



    # --- Port_forward CRUD ---

    @mcp.tool()
    async def unifi_list_port_forwards(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all port_forwards.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/portforward", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} port_forwards")


    @mcp.tool()
    async def unifi_get_port_forward(id: str, site: str = "") -> dict:
        """Get a single port_forward by ID.

        Args:
            id: The _id of the port_forward.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/portforward/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_port_forward(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new port_forward.

            Args:
                data: Port_forward configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Ensure the destination IP (fwd) is a static address or DHCP reservation on your network.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_port_forward", "data": data},
                    "DRY RUN (POST rest/portforward): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/portforward", json_data=data, site=site or None)
            return _format_response(result, "Created port_forward")


        @mcp.tool()
        async def unifi_update_port_forward(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing port_forward.

            Args:
                id: The _id of the port_forward to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Ensure the destination IP (fwd) is a static address or DHCP reservation on your network.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_port_forward", "id": id, "data": data},
                    "DRY RUN (PUT rest/portforward/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/portforward/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated port_forward")


        @mcp.tool()
        async def unifi_delete_port_forward(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a port_forward.

            Args:
                id: The _id of the port_forward to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_port_forward", "id": id},
                    "DRY RUN (DELETE rest/portforward/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/portforward/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted port_forward")



    # --- Route CRUD ---

    @mcp.tool()
    async def unifi_list_routes(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all routes.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/routing", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} routes")


    @mcp.tool()
    async def unifi_get_route(id: str, site: str = "") -> dict:
        """Get a single route by ID.

        Args:
            id: The _id of the route.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/routing/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_route(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new route.

            Args:
                data: Route configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_route", "data": data},
                    "DRY RUN (POST rest/routing): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/routing", json_data=data, site=site or None)
            return _format_response(result, "Created route")


        @mcp.tool()
        async def unifi_update_route(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing route.

            Args:
                id: The _id of the route to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_route", "id": id, "data": data},
                    "DRY RUN (PUT rest/routing/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/routing/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated route")


        @mcp.tool()
        async def unifi_delete_route(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a route.

            Args:
                id: The _id of the route to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_route", "id": id},
                    "DRY RUN (DELETE rest/routing/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/routing/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted route")



if "firewall" in UNIFI_MODULES or "v2" in UNIFI_MODULES:
    
    # --- v2: Firewall_policy ---

    @mcp.tool()
    async def unifi_list_firewall_policies(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all firewall_policies (v2 API).

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/firewall-policies".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} firewall_policies")
        return _format_response(data)


    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_firewall_policy(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new firewall_policy (v2 API).

            Args:
                data: Firewall_policy configuration.
                    Required: action (str), ipVersion (str: 'V4'|'V6'), source (obj with zoneId from unifi_list_firewall_zones), destination (obj with zoneId from unifi_list_firewall_zones), schedule (obj with mode, e.g. {'mode': 'ALWAYS'}). Note: Requires firewall zones which are created when a gateway device is adopted.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_firewall_policy", "data": data},
                    "DRY RUN (POST /v2/api/site/{site}/firewall-policies): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("POST", "/v2/api/site/{site}/firewall-policies".replace("{site}", effective_site), json_data=data)
            return _format_response(result, "Created firewall_policy")


        @mcp.tool()
        async def unifi_update_firewall_policy(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update a firewall_policy (v2 API).

            Args:
                id: The ID of the firewall_policy to update.
                data: The FULL firewall_policy object with your changes applied.
                    v2 API requires sending the complete object, not just changed fields.
                    First GET the current object, modify the fields you want, then send the full object.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_firewall_policy", "id": id, "data": data},
                    "DRY RUN (PUT /v2/api/site/{site}/firewall-policies/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("PUT", "/v2/api/site/{site}/firewall-policies/{id}".replace("{site}", effective_site).format(id=id), json_data=data)
            return _format_response(result, "Updated firewall_policy")


        @mcp.tool()
        async def unifi_delete_firewall_policy(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a firewall_policy (v2 API).

            Args:
                id: The ID of the firewall_policy to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_firewall_policy", "id": id},
                    "DRY RUN (DELETE /v2/api/site/{site}/firewall-policies/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("DELETE", "/v2/api/site/{site}/firewall-policies/{id}".replace("{site}", effective_site).format(id=id))
            return _format_response(result, "Deleted firewall_policy")



    # --- v2: Firewall_zone ---

    @mcp.tool()
    async def unifi_list_firewall_zones(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all firewall_zones (v2 API).

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/firewall/zone".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} firewall_zones")
        return _format_response(data)


    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_update_firewall_zone(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update a firewall_zone (v2 API).

            Args:
                id: The ID of the firewall_zone to update.
                data: The FULL firewall_zone object with your changes applied.
                    v2 API requires sending the complete object, not just changed fields.
                    First GET the current object, modify the fields you want, then send the full object.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_firewall_zone", "id": id, "data": data},
                    "DRY RUN (PUT /v2/api/site/{site}/firewall/zone/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("PUT", "/v2/api/site/{site}/firewall/zone/{id}".replace("{site}", effective_site).format(id=id), json_data=data)
            return _format_response(result, "Updated firewall_zone")



    # --- v2: Traffic_rule ---

    @mcp.tool()
    async def unifi_list_traffic_rules(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all traffic_rules (v2 API).

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/trafficrules".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} traffic_rules")
        return _format_response(data)


    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_traffic_rule(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new traffic_rule (v2 API).

            Args:
                data: Traffic_rule configuration.
                    Required: action (str: 'BLOCK'|'ALLOW'), enabled (bool), matching_target (str: 'INTERNET'|'LOCAL_NETWORK'), target_devices (list of {type: 'ALL_CLIENTS'|'CLIENT'|'NETWORK', client_mac/network_id}), network_id (str, _id from unifi_list_networks)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_traffic_rule", "data": data},
                    "DRY RUN (POST /v2/api/site/{site}/trafficrules): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("POST", "/v2/api/site/{site}/trafficrules".replace("{site}", effective_site), json_data=data)
            return _format_response(result, "Created traffic_rule")


        @mcp.tool()
        async def unifi_update_traffic_rule(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update a traffic_rule (v2 API).

            Args:
                id: The ID of the traffic_rule to update.
                data: The FULL traffic_rule object with your changes applied.
                    v2 API requires sending the complete object, not just changed fields.
                    First GET the current object, modify the fields you want, then send the full object.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_traffic_rule", "id": id, "data": data},
                    "DRY RUN (PUT /v2/api/site/{site}/trafficrules/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("PUT", "/v2/api/site/{site}/trafficrules/{id}".replace("{site}", effective_site).format(id=id), json_data=data)
            return _format_response(result, "Updated traffic_rule")


        @mcp.tool()
        async def unifi_delete_traffic_rule(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a traffic_rule (v2 API).

            Args:
                id: The ID of the traffic_rule to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_traffic_rule", "id": id},
                    "DRY RUN (DELETE /v2/api/site/{site}/trafficrules/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("DELETE", "/v2/api/site/{site}/trafficrules/{id}".replace("{site}", effective_site).format(id=id))
            return _format_response(result, "Deleted traffic_rule")



    # --- v2: Traffic_route ---

    @mcp.tool()
    async def unifi_list_traffic_routes(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all traffic_routes (v2 API).

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        effective_site = site or UNIFI_SITE
        data = await client.request("GET", "/v2/api/site/{site}/trafficroutes".replace("{site}", effective_site))
        if isinstance(data, list):
            total = len(data)
            data = _paginate_and_filter(data, limit, offset, fields)
            return _format_response(data, f"Found {total} traffic_routes")
        return _format_response(data)


    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_update_traffic_route(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update a traffic_route (v2 API).

            Args:
                id: The ID of the traffic_route to update.
                data: The FULL traffic_route object with your changes applied.
                    v2 API requires sending the complete object, not just changed fields.
                    First GET the current object, modify the fields you want, then send the full object.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_traffic_route", "id": id, "data": data},
                    "DRY RUN (PUT /v2/api/site/{site}/trafficroutes/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            effective_site = site or UNIFI_SITE
            result = await client.request("PUT", "/v2/api/site/{site}/trafficroutes/{id}".replace("{site}", effective_site).format(id=id), json_data=data)
            return _format_response(result, "Updated traffic_route")



if "monitor" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: monitor
    # ===========================================================================

    # --- Alarm (read-only) ---

    @mcp.tool()
    async def unifi_list_alarms(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all alarms.

        Returns alarms from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/alarm", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} alarms")



    # --- Event (read-only) ---

    @mcp.tool()
    async def unifi_list_events(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all events.

        Returns events from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/event", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} events")



    @mcp.tool()
    async def unifi_list_stat_alarms(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List stat_alarms statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/alarm", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} stat_alarms records")



    @mcp.tool()
    async def unifi_list_anomalies(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List anomalies statistics.

        Note: site anomalies (unpoller). Supports ?scale=hourly&end=<timestamp>

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/anomalies", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} anomalies records")



    @mcp.tool()
    async def unifi_list_authorizations(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List authorizations statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/authorization", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} authorizations records")



    @mcp.tool()
    async def unifi_list_dashboard(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List dashboard statistics.

        Key fields: time

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/dashboard", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dashboard records")



    @mcp.tool()
    async def unifi_list_dpi_stats(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List dpi_stats statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/dpi", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dpi_stats records")



    @mcp.tool()
    async def unifi_list_dynamic_dns_stats(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List dynamic_dns_stats statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/dynamicdns", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dynamic_dns_stats records")



    @mcp.tool()
    async def unifi_list_stat_events(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List stat_events statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/event", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} stat_events records")



    @mcp.tool()
    async def unifi_list_gateway_stats(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List gateway_stats statistics.

        Note: needs adopted USG/UDM gateway

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/gateway", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} gateway_stats records")



    @mcp.tool()
    async def unifi_list_health(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List health statistics.

        Key fields: status, subsystem

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/health", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} health records")



    @mcp.tool()
    async def unifi_list_ips_events(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List ips_events statistics.

        Note: IDS/IPS events â€” singular form (unpoller APIEventPathIDS)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/ips/event", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} ips_events records")



    @mcp.tool()
    async def unifi_list_port_forward_stats(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List port_forward_stats statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/portforward", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} port_forward_stats records")



    @mcp.tool()
    async def unifi_list_remote_user_vpn(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List remote_user_vpn statistics.

        Note: remote user VPN stats

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/remoteuservpn", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} remote_user_vpn records")



    @mcp.tool()
    async def unifi_list_report(
        interval: str = "hourly",
        report_type: str = "site",
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """Get statistical reports.

        Args:
            interval: Report interval: '5minutes', 'hourly', or 'daily'.
            report_type: Report type: 'site', 'user', 'ap'.
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        Note: intervals: 5minutes, hourly, daily, monthly; types: site, ap, user, gw

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        path = f"stat/report/{interval}.{report_type}"
        data = await client.request("POST", path, json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report records")



    @mcp.tool()
    async def unifi_list_report_5min_ap(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_5min_ap statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/5minutes.ap", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_5min_ap records")



    @mcp.tool()
    async def unifi_list_report_5min_gateway(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_5min_gateway statistics.

        Note: 5-minute gateway stats

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/5minutes.gw", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_5min_gateway records")



    @mcp.tool()
    async def unifi_list_speedtest_results(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List speedtest_results statistics.

        Note: archived speedtest results with start/end timestamps (Art-of-WiFi)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/archive.speedtest", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} speedtest_results records")



    @mcp.tool()
    async def unifi_list_report_daily_gateway(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_daily_gateway statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/daily.gw", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_daily_gateway records")



    @mcp.tool()
    async def unifi_list_report_hourly_gateway(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_hourly_gateway statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/hourly.gw", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_hourly_gateway records")



    @mcp.tool()
    async def unifi_list_report_monthly_ap(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_monthly_ap statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/monthly.ap", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_monthly_ap records")



    @mcp.tool()
    async def unifi_list_report_monthly_gateway(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_monthly_gateway statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/monthly.gw", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_monthly_gateway records")



    @mcp.tool()
    async def unifi_list_report_monthly_site(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_monthly_site statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/monthly.site", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_monthly_site records")



    @mcp.tool()
    async def unifi_list_report_monthly_user(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List report_monthly_user statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "stat/report/monthly.user", json_data={}, site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} report_monthly_user records")



    @mcp.tool()
    async def unifi_list_rogue_aps(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List rogue_aps statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/rogueap", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} rogue_aps records")



    @mcp.tool()
    async def unifi_list_routing_stats(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List routing_stats statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/routing", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} routing_stats records")



    @mcp.tool()
    async def unifi_list_sdn_status(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List sdn_status statistics.

        Key fields: cloud_env, connected, connecting, enabled, has_sso_auth

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/sdn", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} sdn_status records")



    @mcp.tool()
    async def unifi_list_site_dpi(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List site_dpi statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/sitedpi", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} site_dpi records")



    @mcp.tool()
    async def unifi_list_client_dpi(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List client_dpi statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/stadpi", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} client_dpi records")



    @mcp.tool()
    async def unifi_list_sysinfo(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List sysinfo statistics.

        Key fields: anonymous_controller_id, autobackup, build, data_retention_days, data_retention_time_in_hours_for_5minutes_scale

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/sysinfo", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} sysinfo records")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_alarm_archive(
            _id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'archive' via alarm.

            Args:
                _id: _id parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "alarm_archive", "cmd": "archive"}
                preview["_id"] = _id
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/alarm): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "archive"}
            payload["_id"] = _id
            client = await _get_client()
            result = await client.request("POST", "cmd/alarm", json_data=payload, site=site or None)
            return _format_response(result, "Executed archive")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_archive_all_alarms(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'archive-all-alarms' via evtmgr.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "archive_all_alarms", "cmd": "archive-all-alarms"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/evtmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "archive-all-alarms"}
            client = await _get_client()
            result = await client.request("POST", "cmd/evtmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed archive-all-alarms")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_archive_alarm(
            _id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'archive-alarm' via evtmgr.

            Args:
                _id: _id parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "archive_alarm", "cmd": "archive-alarm"}
                preview["_id"] = _id
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/evtmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "archive-alarm"}
            payload["_id"] = _id
            client = await _get_client()
            result = await client.request("POST", "cmd/evtmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed archive-alarm")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_clear_dpi(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'reset-dpi' via stat.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "clear_dpi", "cmd": "reset-dpi"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/stat): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "reset-dpi"}
            client = await _get_client()
            result = await client.request("POST", "cmd/stat", json_data=payload, site=site or None)
            return _format_response(result, "Executed reset-dpi")



if "admin" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: admin
    # ===========================================================================

    # --- Account CRUD ---

    @mcp.tool()
    async def unifi_list_accounts(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all accounts.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/account", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} accounts")


    @mcp.tool()
    async def unifi_get_account(id: str, site: str = "") -> dict:
        """Get a single account by ID.

        Args:
            id: The _id of the account.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/account/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_account(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new account.

            Args:
                data: Account configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_account", "data": data},
                    "DRY RUN (POST rest/account): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/account", json_data=data, site=site or None)
            return _format_response(result, "Created account")


        @mcp.tool()
        async def unifi_update_account(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing account.

            Args:
                id: The _id of the account to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_account", "id": id, "data": data},
                    "DRY RUN (PUT rest/account/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/account/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated account")


        @mcp.tool()
        async def unifi_delete_account(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a account.

            Args:
                id: The _id of the account to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_account", "id": id},
                    "DRY RUN (DELETE rest/account/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/account/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted account")



    # --- Settings (special handling: keyed by 'key' field) ---

    @mcp.tool()
    async def unifi_list_settings(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all site settings. Returns all setting categories.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'key,name'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/setting", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} setting categories")


    @mcp.tool()
    async def unifi_get_setting(key: str, site: str = "") -> dict:
        """Get a specific site setting by key (e.g. 'super_identity', 'snmp').

        Args:
            key: The setting key to retrieve.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/setting", site=site or None)
        for item in data:
            if isinstance(item, dict) and item.get("key") == key:
                return _format_response(item)
        return _format_response(None, f"Setting '{key}' not found")

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_update_setting(
            key: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update a site setting by key.

            Args:
                key: The setting key to update (e.g. 'mgmt', 'snmp', 'ntp', 'locale').
                data: Fields to update. Read current values first with unifi_get_setting.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_setting", "key": key, "data": data},
                    "DRY RUN (PUT set/setting/{key}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", f"set/setting/{key}", json_data=data, site=site or None)
            return _format_response(result, f"Updated setting '{key}'")



    # --- Tag CRUD ---

    @mcp.tool()
    async def unifi_list_tags(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all tags.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/tag", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} tags")


    @mcp.tool()
    async def unifi_get_tag(id: str, site: str = "") -> dict:
        """Get a single tag by ID.

        Args:
            id: The _id of the tag.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/tag/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_tag(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new tag.

            Args:
                data: Tag configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_tag", "data": data},
                    "DRY RUN (POST rest/tag): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/tag", json_data=data, site=site or None)
            return _format_response(result, "Created tag")


        @mcp.tool()
        async def unifi_update_tag(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing tag.

            Args:
                id: The _id of the tag to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_tag", "id": id, "data": data},
                    "DRY RUN (PUT rest/tag/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/tag/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated tag")


        @mcp.tool()
        async def unifi_delete_tag(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a tag.

            Args:
                id: The _id of the tag to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_tag", "id": id},
                    "DRY RUN (DELETE rest/tag/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/tag/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted tag")



    # --- User_group CRUD ---

    @mcp.tool()
    async def unifi_list_user_groups(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all user_groups.

        Key fields: name (str), qos_rate_max_down (int), qos_rate_max_up (int)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/usergroup", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} user_groups")


    @mcp.tool()
    async def unifi_get_user_group(id: str, site: str = "") -> dict:
        """Get a single user_group by ID.

        Args:
            id: The _id of the user_group.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/usergroup/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_user_group(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new user_group.

            Args:
                data: User_group configuration.
                    Fields: name (str), qos_rate_max_down (int), qos_rate_max_up (int)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Assign users to this group by setting usergroup_id when creating or updating users.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_user_group", "data": data},
                    "DRY RUN (POST rest/usergroup): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/usergroup", json_data=data, site=site or None)
            return _format_response(result, "Created user_group")


        @mcp.tool()
        async def unifi_update_user_group(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing user_group.

            Args:
                id: The _id of the user_group to update.
                data: Fields to update.
                    Fields: name (str), qos_rate_max_down (int), qos_rate_max_up (int)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Assign users to this group by setting usergroup_id when creating or updating users.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_user_group", "id": id, "data": data},
                    "DRY RUN (PUT rest/usergroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/usergroup/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated user_group")


        @mcp.tool()
        async def unifi_delete_user_group(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a user_group.

            Args:
                id: The _id of the user_group to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_user_group", "id": id},
                    "DRY RUN (DELETE rest/usergroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/usergroup/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted user_group")



    @mcp.tool()
    async def unifi_list_backups(
        site: str = "",
    ) -> dict:
        """Execute 'list-backups' via backup.

            site: Site name override (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        payload: dict[str, Any] = {"cmd": "list-backups"}
        client = await _get_client()
        result = await client.request("POST", "cmd/backup", json_data=payload, site=site or None)
        return _format_response(result, "Executed list-backups")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_delete_backup(
            filename: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'delete-backup' via backup.

            Args:
                filename: filename parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "delete_backup", "cmd": "delete-backup"}
                preview["filename"] = filename
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/backup): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "delete-backup"}
            payload["filename"] = filename
            client = await _get_client()
            result = await client.request("POST", "cmd/backup", json_data=payload, site=site or None)
            return _format_response(result, "Executed delete-backup")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_generate_backup(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'generate-backup' via backup.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "generate_backup", "cmd": "generate-backup"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/backup): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "generate-backup"}
            client = await _get_client()
            result = await client.request("POST", "cmd/backup", json_data=payload, site=site or None)
            return _format_response(result, "Executed generate-backup")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_generate_backup_site(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'generate-backup-site' via backup.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "generate_backup_site", "cmd": "generate-backup-site"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/backup): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "generate-backup-site"}
            client = await _get_client()
            result = await client.request("POST", "cmd/backup", json_data=payload, site=site or None)
            return _format_response(result, "Executed generate-backup-site")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_rolling_upgrade(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'rolling-upgrade' via devmgr.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "rolling_upgrade", "cmd": "rolling-upgrade"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "rolling-upgrade"}
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed rolling-upgrade")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_cancel_rolling_upgrade(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'cancel-rolling-upgrade' via devmgr.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "cancel_rolling_upgrade", "cmd": "cancel-rolling-upgrade"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "cancel-rolling-upgrade"}
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed cancel-rolling-upgrade")



    @mcp.tool()
    async def unifi_check_firmware_update(
        site: str = "",
    ) -> dict:
        """Execute 'check-firmware-update' via devmgr.

            site: Site name override (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        payload: dict[str, Any] = {"cmd": "check-firmware-update"}
        client = await _get_client()
        result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
        return _format_response(result, "Executed check-firmware-update")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_set_rollupgrade(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'set-rollupgrade' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "set_rollupgrade", "cmd": "set-rollupgrade"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "set-rollupgrade"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed set-rollupgrade")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_unset_rollupgrade(
            mac: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'unset-rollupgrade' via devmgr.

            Args:
                mac: mac parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "unset_rollupgrade", "cmd": "unset-rollupgrade"}
                preview["mac"] = mac
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/devmgr): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "unset-rollupgrade"}
            payload["mac"] = mac
            client = await _get_client()
            result = await client.request("POST", "cmd/devmgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed unset-rollupgrade")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_add_site(
            desc: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'add-site' via sitemgr.

            Args:
                desc: desc parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "add_site", "cmd": "add-site"}
                preview["desc"] = desc
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "add-site"}
            payload["desc"] = desc
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed add-site")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_delete_site(
            target_site: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'delete-site' via sitemgr.

            Args:
                target_site: Target site for the command (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "delete_site", "cmd": "delete-site"}
                preview["site"] = target_site
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "delete-site"}
            payload["site"] = target_site
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed delete-site")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_update_site(
            desc: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'update-site' via sitemgr.

            Args:
                desc: desc parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "update_site", "cmd": "update-site"}
                preview["desc"] = desc
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "update-site"}
            payload["desc"] = desc
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed update-site")



    @mcp.tool()
    async def unifi_get_admins(
        site: str = "",
    ) -> dict:
        """Execute 'get-admins' via sitemgr.

            site: Site name override (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        payload: dict[str, Any] = {"cmd": "get-admins"}
        client = await _get_client()
        result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
        return _format_response(result, "Executed get-admins")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_set_site_leds(
            led_enabled: bool,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'site-leds' via sitemgr.

            Args:
                led_enabled: led_enabled parameter (bool).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "set_site_leds", "cmd": "site-leds"}
                preview["led_enabled"] = led_enabled
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "site-leds"}
            payload["led_enabled"] = led_enabled
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed site-leds")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_invite_admin(
            email: str,
            name: str,
            role: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'invite-admin' via sitemgr.

            Args:
                email: email parameter (str).
            Args:
                name: name parameter (str).
            Args:
                role: role parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "invite_admin", "cmd": "invite-admin"}
                preview["email"] = email
                preview["name"] = name
                preview["role"] = role
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "invite-admin"}
            payload["email"] = email
            payload["name"] = name
            payload["role"] = role
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed invite-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_assign_existing_admin(
            admin: str,
            role: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'assign-existing-admin' via sitemgr.

            Args:
                admin: admin parameter (str).
            Args:
                role: role parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "assign_existing_admin", "cmd": "assign-existing-admin"}
                preview["admin"] = admin
                preview["role"] = role
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "assign-existing-admin"}
            payload["admin"] = admin
            payload["role"] = role
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed assign-existing-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_update_admin(
            admin: str,
            role: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'update-admin' via sitemgr.

            Args:
                admin: admin parameter (str).
            Args:
                role: role parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "update_admin", "cmd": "update-admin"}
                preview["admin"] = admin
                preview["role"] = role
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "update-admin"}
            payload["admin"] = admin
            payload["role"] = role
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed update-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_revoke_admin(
            admin: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'revoke-admin' via sitemgr.

            Args:
                admin: admin parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "revoke_admin", "cmd": "revoke-admin"}
                preview["admin"] = admin
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "revoke-admin"}
            payload["admin"] = admin
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed revoke-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_grant_super_admin(
            admin: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'grant-super-admin' via sitemgr.

            Args:
                admin: admin parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "grant_super_admin", "cmd": "grant-super-admin"}
                preview["admin"] = admin
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "grant-super-admin"}
            payload["admin"] = admin
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed grant-super-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_admin(
            name: str,
            email: str,
            x_password: str,
            role: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'create-admin' via sitemgr.

            Args:
                name: name parameter (str).
            Args:
                email: email parameter (str).
            Args:
                x_password: x_password parameter (str).
            Args:
                role: role parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "create_admin", "cmd": "create-admin"}
                preview["name"] = name
                preview["email"] = email
                preview["x_password"] = x_password
                preview["role"] = role
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "create-admin"}
            payload["name"] = name
            payload["email"] = email
            payload["x_password"] = x_password
            payload["role"] = role
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed create-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_revoke_super_admin(
            admin: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'revoke-super-admin' via sitemgr.

            Args:
                admin: admin parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "revoke_super_admin", "cmd": "revoke-super-admin"}
                preview["admin"] = admin
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/sitemgr): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "revoke-super-admin"}
            payload["admin"] = admin
            client = await _get_client()
            result = await client.request("POST", "cmd/sitemgr", json_data=payload, site=site or None)
            return _format_response(result, "Executed revoke-super-admin")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_backup(
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'backup' via system.

                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "create_backup", "cmd": "backup"}
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/system): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "backup"}
            client = await _get_client()
            result = await client.request("POST", "cmd/system", json_data=payload, site=site or None)
            return _format_response(result, "Executed backup")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_download_backup(
            filename: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'download-backup' via system.

            Args:
                filename: filename parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "download_backup", "cmd": "download-backup"}
                preview["filename"] = filename
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/system): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "download-backup"}
            payload["filename"] = filename
            client = await _get_client()
            result = await client.request("POST", "cmd/system", json_data=payload, site=site or None)
            return _format_response(result, "Executed download-backup")



if "hotspot" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: hotspot
    # ===========================================================================

    # --- Hotspot2_config CRUD ---

    @mcp.tool()
    async def unifi_list_hotspot2_configs(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all hotspot2_configs.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/hotspot2conf", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} hotspot2_configs")


    @mcp.tool()
    async def unifi_get_hotspot2_config(id: str, site: str = "") -> dict:
        """Get a single hotspot2_config by ID.

        Args:
            id: The _id of the hotspot2_config.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/hotspot2conf/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_hotspot2_config(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new hotspot2_config.

            Args:
                data: Hotspot2_config configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_hotspot2_config", "data": data},
                    "DRY RUN (POST rest/hotspot2conf): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/hotspot2conf", json_data=data, site=site or None)
            return _format_response(result, "Created hotspot2_config")


        @mcp.tool()
        async def unifi_update_hotspot2_config(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing hotspot2_config.

            Args:
                id: The _id of the hotspot2_config to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_hotspot2_config", "id": id, "data": data},
                    "DRY RUN (PUT rest/hotspot2conf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/hotspot2conf/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated hotspot2_config")


        @mcp.tool()
        async def unifi_delete_hotspot2_config(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a hotspot2_config.

            Args:
                id: The _id of the hotspot2_config to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_hotspot2_config", "id": id},
                    "DRY RUN (DELETE rest/hotspot2conf/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/hotspot2conf/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted hotspot2_config")



    # --- Hotspot_operator CRUD ---

    @mcp.tool()
    async def unifi_list_hotspot_operators(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all hotspot_operators.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/hotspotop", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} hotspot_operators")


    @mcp.tool()
    async def unifi_get_hotspot_operator(id: str, site: str = "") -> dict:
        """Get a single hotspot_operator by ID.

        Args:
            id: The _id of the hotspot_operator.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/hotspotop/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_hotspot_operator(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new hotspot_operator.

            Args:
                data: Hotspot_operator configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_hotspot_operator", "data": data},
                    "DRY RUN (POST rest/hotspotop): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/hotspotop", json_data=data, site=site or None)
            return _format_response(result, "Created hotspot_operator")


        @mcp.tool()
        async def unifi_update_hotspot_operator(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing hotspot_operator.

            Args:
                id: The _id of the hotspot_operator to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_hotspot_operator", "id": id, "data": data},
                    "DRY RUN (PUT rest/hotspotop/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/hotspotop/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated hotspot_operator")


        @mcp.tool()
        async def unifi_delete_hotspot_operator(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a hotspot_operator.

            Args:
                id: The _id of the hotspot_operator to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_hotspot_operator", "id": id},
                    "DRY RUN (DELETE rest/hotspotop/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/hotspotop/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted hotspot_operator")



    # --- Hotspot_package CRUD ---

    @mcp.tool()
    async def unifi_list_hotspot_packages(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all hotspot_packages.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/hotspotpackage", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} hotspot_packages")


    @mcp.tool()
    async def unifi_get_hotspot_package(id: str, site: str = "") -> dict:
        """Get a single hotspot_package by ID.

        Args:
            id: The _id of the hotspot_package.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/hotspotpackage/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_hotspot_package(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new hotspot_package.

            Args:
                data: Hotspot_package configuration.
                    Required: name (str), amount (int, price in cents, 0=free), currency (str, e.g. 'USD'), hours (int, access duration in hours), bytes (int, bandwidth limit, 0=unlimited). Note: Requires hotspot portal + payment gateway configured on the controller.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_hotspot_package", "data": data},
                    "DRY RUN (POST rest/hotspotpackage): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/hotspotpackage", json_data=data, site=site or None)
            return _format_response(result, "Created hotspot_package")


        @mcp.tool()
        async def unifi_update_hotspot_package(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing hotspot_package.

            Args:
                id: The _id of the hotspot_package to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_hotspot_package", "id": id, "data": data},
                    "DRY RUN (PUT rest/hotspotpackage/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/hotspotpackage/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated hotspot_package")


        @mcp.tool()
        async def unifi_delete_hotspot_package(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a hotspot_package.

            Args:
                id: The _id of the hotspot_package to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_hotspot_package", "id": id},
                    "DRY RUN (DELETE rest/hotspotpackage/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/hotspotpackage/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted hotspot_package")



    # --- Radius_account CRUD ---

    @mcp.tool()
    async def unifi_list_radius_accounts(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all radius_accounts.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/radiusaccount", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} radius_accounts")


    @mcp.tool()
    async def unifi_get_radius_account(id: str, site: str = "") -> dict:
        """Get a single radius_account by ID.

        Args:
            id: The _id of the radius_account.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/radiusaccount/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_radius_account(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new radius_account.

            Args:
                data: Radius_account configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_radius_account", "data": data},
                    "DRY RUN (POST rest/radiusaccount): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/radiusaccount", json_data=data, site=site or None)
            return _format_response(result, "Created radius_account")


        @mcp.tool()
        async def unifi_update_radius_account(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing radius_account.

            Args:
                id: The _id of the radius_account to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_radius_account", "id": id, "data": data},
                    "DRY RUN (PUT rest/radiusaccount/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/radiusaccount/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated radius_account")


        @mcp.tool()
        async def unifi_delete_radius_account(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a radius_account.

            Args:
                id: The _id of the radius_account to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_radius_account", "id": id},
                    "DRY RUN (DELETE rest/radiusaccount/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/radiusaccount/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted radius_account")



    # --- Radius_profile CRUD ---

    @mcp.tool()
    async def unifi_list_radius_profiles(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all radius_profiles.

        Key fields: acct_servers (list), auth_servers (list), external_id (str), name (str), use_usg_auth_server (bool)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/radiusprofile", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} radius_profiles")


    @mcp.tool()
    async def unifi_get_radius_profile(id: str, site: str = "") -> dict:
        """Get a single radius_profile by ID.

        Args:
            id: The _id of the radius_profile.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/radiusprofile/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_radius_profile(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new radius_profile.

            Args:
                data: Radius_profile configuration.
                    Fields: acct_servers (list), auth_servers (list), external_id (str), name (str), use_usg_auth_server (bool)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Reference this profile's _id as radiusprofile_id when configuring WLANs with 802.1X authentication.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_radius_profile", "data": data},
                    "DRY RUN (POST rest/radiusprofile): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/radiusprofile", json_data=data, site=site or None)
            return _format_response(result, "Created radius_profile")


        @mcp.tool()
        async def unifi_update_radius_profile(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing radius_profile.

            Args:
                id: The _id of the radius_profile to update.
                data: Fields to update.
                    Fields: acct_servers (list), auth_servers (list), external_id (str), name (str), use_usg_auth_server (bool)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Tip: Reference this profile's _id as radiusprofile_id when configuring WLANs with 802.1X authentication.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_radius_profile", "id": id, "data": data},
                    "DRY RUN (PUT rest/radiusprofile/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/radiusprofile/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated radius_profile")


        @mcp.tool()
        async def unifi_delete_radius_profile(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a radius_profile.

            Args:
                id: The _id of the radius_profile to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_radius_profile", "id": id},
                    "DRY RUN (DELETE rest/radiusprofile/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/radiusprofile/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted radius_profile")



    @mcp.tool()
    async def unifi_list_payments(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List payments statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/payment", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} payments records")



    @mcp.tool()
    async def unifi_list_vouchers(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List vouchers statistics.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "stat/voucher", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} vouchers records")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_hotspot_authorize_guest(
            mac: str,
            minutes: int,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'authorize-guest' via hotspot.

            Args:
                mac: mac parameter (str).
            Args:
                minutes: minutes parameter (int).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "hotspot_authorize_guest", "cmd": "authorize-guest"}
                preview["mac"] = mac
                preview["minutes"] = minutes
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/hotspot): Set confirm=True to execute.",
                )
            mac_err = _validate_mac(mac)
            if mac_err:
                return _format_response({"error": mac_err}, mac_err)
            payload: dict[str, Any] = {"cmd": "authorize-guest"}
            payload["mac"] = mac
            payload["minutes"] = minutes
            client = await _get_client()
            result = await client.request("POST", "cmd/hotspot", json_data=payload, site=site or None)
            return _format_response(result, "Executed authorize-guest")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_voucher(
            expire: int,
            n: int,
            quota: int,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'create-voucher' via hotspot.

            Args:
                expire: expire parameter (int).
            Args:
                n: n parameter (int).
            Args:
                quota: quota parameter (int).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "create_voucher", "cmd": "create-voucher"}
                preview["expire"] = expire
                preview["n"] = n
                preview["quota"] = quota
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/hotspot): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "create-voucher"}
            payload["expire"] = expire
            payload["n"] = n
            payload["quota"] = quota
            client = await _get_client()
            result = await client.request("POST", "cmd/hotspot", json_data=payload, site=site or None)
            return _format_response(result, "Executed create-voucher")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_revoke_voucher(
            _id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'revoke-voucher' via hotspot.

            Args:
                _id: _id parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "revoke_voucher", "cmd": "revoke-voucher"}
                preview["_id"] = _id
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/hotspot): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "revoke-voucher"}
            payload["_id"] = _id
            client = await _get_client()
            result = await client.request("POST", "cmd/hotspot", json_data=payload, site=site or None)
            return _format_response(result, "Executed revoke-voucher")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_extend_guest_validity(
            _id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'extend-guest-validity' via hotspot.

            Args:
                _id: _id parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "extend_guest_validity", "cmd": "extend-guest-validity"}
                preview["_id"] = _id
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/hotspot): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "extend-guest-validity"}
            payload["_id"] = _id
            client = await _get_client()
            result = await client.request("POST", "cmd/hotspot", json_data=payload, site=site or None)
            return _format_response(result, "Executed extend-guest-validity")



    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_delete_voucher(
            _id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Execute 'delete-voucher' via hotspot.

            Args:
                _id: _id parameter (str).
                confirm: Must be True to execute. Returns preview if False.
                site: Site name override (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                preview = {"action": "delete_voucher", "cmd": "delete-voucher"}
                preview["_id"] = _id
                return _format_response(
                    preview,
                    "DRY RUN (POST cmd/hotspot): Set confirm=True to execute.",
                )
            payload: dict[str, Any] = {"cmd": "delete-voucher"}
            payload["_id"] = _id
            client = await _get_client()
            result = await client.request("POST", "cmd/hotspot", json_data=payload, site=site or None)
            return _format_response(result, "Executed delete-voucher")



if "advanced" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
    # ===========================================================================
    # Module: advanced
    # ===========================================================================

    # --- Broadcast_group CRUD ---

    @mcp.tool()
    async def unifi_list_broadcast_groups(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all broadcast_groups.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/broadcastgroup", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} broadcast_groups")


    @mcp.tool()
    async def unifi_get_broadcast_group(id: str, site: str = "") -> dict:
        """Get a single broadcast_group by ID.

        Args:
            id: The _id of the broadcast_group.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/broadcastgroup/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_broadcast_group(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new broadcast_group.

            Args:
                data: Broadcast_group configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_broadcast_group", "data": data},
                    "DRY RUN (POST rest/broadcastgroup): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/broadcastgroup", json_data=data, site=site or None)
            return _format_response(result, "Created broadcast_group")


        @mcp.tool()
        async def unifi_update_broadcast_group(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing broadcast_group.

            Args:
                id: The _id of the broadcast_group to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_broadcast_group", "id": id, "data": data},
                    "DRY RUN (PUT rest/broadcastgroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/broadcastgroup/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated broadcast_group")


        @mcp.tool()
        async def unifi_delete_broadcast_group(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a broadcast_group.

            Args:
                id: The _id of the broadcast_group to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_broadcast_group", "id": id},
                    "DRY RUN (DELETE rest/broadcastgroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/broadcastgroup/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted broadcast_group")



    # --- Dpi_app CRUD ---

    @mcp.tool()
    async def unifi_list_dpi_apps(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all dpi_apps.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dpiapp", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dpi_apps")


    @mcp.tool()
    async def unifi_get_dpi_app(id: str, site: str = "") -> dict:
        """Get a single dpi_app by ID.

        Args:
            id: The _id of the dpi_app.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dpiapp/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_dpi_app(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new dpi_app.

            Args:
                data: Dpi_app configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_dpi_app", "data": data},
                    "DRY RUN (POST rest/dpiapp): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/dpiapp", json_data=data, site=site or None)
            return _format_response(result, "Created dpi_app")


        @mcp.tool()
        async def unifi_update_dpi_app(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing dpi_app.

            Args:
                id: The _id of the dpi_app to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_dpi_app", "id": id, "data": data},
                    "DRY RUN (PUT rest/dpiapp/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/dpiapp/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated dpi_app")


        @mcp.tool()
        async def unifi_delete_dpi_app(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a dpi_app.

            Args:
                id: The _id of the dpi_app to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_dpi_app", "id": id},
                    "DRY RUN (DELETE rest/dpiapp/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/dpiapp/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted dpi_app")



    # --- Dpi_group CRUD ---

    @mcp.tool()
    async def unifi_list_dpi_groups(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all dpi_groups.

        Key fields: name (str)

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dpigroup", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} dpi_groups")


    @mcp.tool()
    async def unifi_get_dpi_group(id: str, site: str = "") -> dict:
        """Get a single dpi_group by ID.

        Args:
            id: The _id of the dpi_group.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/dpigroup/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_dpi_group(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new dpi_group.

            Args:
                data: Dpi_group configuration.
                    Fields: name (str)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_dpi_group", "data": data},
                    "DRY RUN (POST rest/dpigroup): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/dpigroup", json_data=data, site=site or None)
            return _format_response(result, "Created dpi_group")


        @mcp.tool()
        async def unifi_update_dpi_group(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing dpi_group.

            Args:
                id: The _id of the dpi_group to update.
                data: Fields to update.
                    Fields: name (str)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_dpi_group", "id": id, "data": data},
                    "DRY RUN (PUT rest/dpigroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/dpigroup/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated dpi_group")


        @mcp.tool()
        async def unifi_delete_dpi_group(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a dpi_group.

            Args:
                id: The _id of the dpi_group to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_dpi_group", "id": id},
                    "DRY RUN (DELETE rest/dpigroup/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/dpigroup/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted dpi_group")



    # --- Heatmap CRUD ---

    @mcp.tool()
    async def unifi_list_heatmaps(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all heatmaps.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/heatmap", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} heatmaps")


    @mcp.tool()
    async def unifi_get_heatmap(id: str, site: str = "") -> dict:
        """Get a single heatmap by ID.

        Args:
            id: The _id of the heatmap.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/heatmap/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_heatmap(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new heatmap.

            Args:
                data: Heatmap configuration.
                    Required: name (str), map_id (str, _id from unifi_list_maps)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_heatmap", "data": data},
                    "DRY RUN (POST rest/heatmap): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/heatmap", json_data=data, site=site or None)
            return _format_response(result, "Created heatmap")


        @mcp.tool()
        async def unifi_update_heatmap(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing heatmap.

            Args:
                id: The _id of the heatmap to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_heatmap", "id": id, "data": data},
                    "DRY RUN (PUT rest/heatmap/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/heatmap/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated heatmap")


        @mcp.tool()
        async def unifi_delete_heatmap(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a heatmap.

            Args:
                id: The _id of the heatmap to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_heatmap", "id": id},
                    "DRY RUN (DELETE rest/heatmap/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/heatmap/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted heatmap")



    # --- Heatmap_point CRUD ---

    @mcp.tool()
    async def unifi_list_heatmap_points(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all heatmap_points.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/heatmappoint", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} heatmap_points")


    @mcp.tool()
    async def unifi_get_heatmap_point(id: str, site: str = "") -> dict:
        """Get a single heatmap_point by ID.

        Args:
            id: The _id of the heatmap_point.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/heatmappoint/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_heatmap_point(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new heatmap_point.

            Args:
                data: Heatmap_point configuration.
                    Required: heatmap_id (str, _id from unifi_list_heatmaps), x (float, 0.0â€“1.0), y (float, 0.0â€“1.0)
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_heatmap_point", "data": data},
                    "DRY RUN (POST rest/heatmappoint): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/heatmappoint", json_data=data, site=site or None)
            return _format_response(result, "Created heatmap_point")


        @mcp.tool()
        async def unifi_update_heatmap_point(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing heatmap_point.

            Args:
                id: The _id of the heatmap_point to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_heatmap_point", "id": id, "data": data},
                    "DRY RUN (PUT rest/heatmappoint/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/heatmappoint/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated heatmap_point")


        @mcp.tool()
        async def unifi_delete_heatmap_point(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a heatmap_point.

            Args:
                id: The _id of the heatmap_point to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_heatmap_point", "id": id},
                    "DRY RUN (DELETE rest/heatmappoint/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/heatmappoint/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted heatmap_point")



    # --- Map CRUD ---

    @mcp.tool()
    async def unifi_list_maps(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all maps.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/map", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} maps")


    @mcp.tool()
    async def unifi_get_map(id: str, site: str = "") -> dict:
        """Get a single map by ID.

        Args:
            id: The _id of the map.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/map/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_map(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new map.

            Args:
                data: Map configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_map", "data": data},
                    "DRY RUN (POST rest/map): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/map", json_data=data, site=site or None)
            return _format_response(result, "Created map")


        @mcp.tool()
        async def unifi_update_map(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing map.

            Args:
                id: The _id of the map to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_map", "id": id, "data": data},
                    "DRY RUN (PUT rest/map/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/map/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated map")


        @mcp.tool()
        async def unifi_delete_map(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a map.

            Args:
                id: The _id of the map to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_map", "id": id},
                    "DRY RUN (DELETE rest/map/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/map/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted map")



    # --- Media_file CRUD ---

    @mcp.tool()
    async def unifi_list_media_files(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all media_files.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/mediafile", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} media_files")


    @mcp.tool()
    async def unifi_get_media_file(id: str, site: str = "") -> dict:
        """Get a single media_file by ID.

        Args:
            id: The _id of the media_file.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/mediafile/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_media_file(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new media_file.

            Args:
                data: Media_file configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_media_file", "data": data},
                    "DRY RUN (POST rest/mediafile): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/mediafile", json_data=data, site=site or None)
            return _format_response(result, "Created media_file")


        @mcp.tool()
        async def unifi_update_media_file(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing media_file.

            Args:
                id: The _id of the media_file to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_media_file", "id": id, "data": data},
                    "DRY RUN (PUT rest/mediafile/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/mediafile/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated media_file")


        @mcp.tool()
        async def unifi_delete_media_file(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a media_file.

            Args:
                id: The _id of the media_file to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_media_file", "id": id},
                    "DRY RUN (DELETE rest/mediafile/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/mediafile/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted media_file")



    # --- Known_rogue_ap (read-only) ---

    @mcp.tool()
    async def unifi_list_known_rogue_aps(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all known_rogue_aps.

        Returns known_rogue_aps from the UniFi controller.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/rogueknown", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} known_rogue_aps")



    # --- Schedule_task CRUD ---

    @mcp.tool()
    async def unifi_list_schedule_tasks(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all schedule_tasks.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/scheduletask", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} schedule_tasks")


    @mcp.tool()
    async def unifi_get_schedule_task(id: str, site: str = "") -> dict:
        """Get a single schedule_task by ID.

        Args:
            id: The _id of the schedule_task.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/scheduletask/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_schedule_task(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new schedule_task.

            Args:
                data: Schedule_task configuration.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_schedule_task", "data": data},
                    "DRY RUN (POST rest/scheduletask): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/scheduletask", json_data=data, site=site or None)
            return _format_response(result, "Created schedule_task")


        @mcp.tool()
        async def unifi_update_schedule_task(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing schedule_task.

            Args:
                id: The _id of the schedule_task to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            Note: This resource requires sending the FULL object on update, not just changed fields.
            First GET the current object, modify the fields you want, then send the complete object.

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_schedule_task", "id": id, "data": data},
                    "DRY RUN (PUT rest/scheduletask/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/scheduletask/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated schedule_task")


        @mcp.tool()
        async def unifi_delete_schedule_task(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a schedule_task.

            Args:
                id: The _id of the schedule_task to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_schedule_task", "id": id},
                    "DRY RUN (DELETE rest/scheduletask/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/scheduletask/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted schedule_task")



    # --- Spatial_record CRUD ---

    @mcp.tool()
    async def unifi_list_spatial_records(
        site: str = "",
        limit: int = 0,
        offset: int = 0,
        fields: str = "",
    ) -> dict:
        """List all spatial_records.

        Args:
            site: Site name (default: from env).
            limit: Max records to return (0 = all).
            offset: Number of records to skip.
            fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/spatialrecord", site=site or None)
        total = len(data)
        data = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} spatial_records")


    @mcp.tool()
    async def unifi_get_spatial_record(id: str, site: str = "") -> dict:
        """Get a single spatial_record by ID.

        Args:
            id: The _id of the spatial_record.
            site: Site name (default: from env).

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("GET", "rest/spatialrecord/{id}".format(id=id), site=site or None)
        if isinstance(data, list) and len(data) == 1:
            return _format_response(data[0])
        return _format_response(data)

    if not UNIFI_READ_ONLY:
        
        @mcp.tool()
        async def unifi_create_spatial_record(
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Create a new spatial_record.

            Args:
                data: Spatial_record configuration.
                    Required: name (str), devices (list, device references e.g. []), description (str, e.g. 'Room label')
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "create_spatial_record", "data": data},
                    "DRY RUN (POST rest/spatialrecord): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("POST", "rest/spatialrecord", json_data=data, site=site or None)
            return _format_response(result, "Created spatial_record")


        @mcp.tool()
        async def unifi_update_spatial_record(
            id: str,
            data: dict,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Update an existing spatial_record.

            Args:
                id: The _id of the spatial_record to update.
                data: Fields to update.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "update_spatial_record", "id": id, "data": data},
                    "DRY RUN (PUT rest/spatialrecord/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("PUT", "rest/spatialrecord/{id}".format(id=id), json_data=data, site=site or None)
            return _format_response(result, "Updated spatial_record")


        @mcp.tool()
        async def unifi_delete_spatial_record(
            id: str,
            confirm: bool = False,
            site: str = "",
        ) -> dict:
            """Delete a spatial_record.

            Args:
                id: The _id of the spatial_record to delete.
                confirm: Must be True to execute. Returns preview if False.
                site: Site name (default: from env).

            If this tool returns an unexpected error, call unifi_report_issue to report it.
            """
            if not confirm:
                return _format_response(
                    {"action": "delete_spatial_record", "id": id},
                    "DRY RUN (DELETE rest/spatialrecord/{id}): Set confirm=True to execute.",
                )
            client = await _get_client()
            result = await client.request("DELETE", "rest/spatialrecord/{id}".format(id=id), site=site or None)
            return _format_response(result, "Deleted spatial_record")



# ===========================================================================
# Global Endpoint Tools (always-on)
# ===========================================================================

if not UNIFI_READ_ONLY:
    @mcp.tool()
    async def unifi_logout() -> dict:
        """Logout.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "/api/logout")
        return _format_response(data)

@mcp.tool()
async def unifi_self() -> dict:
    """Self.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "/api/self")
    return _format_response(data)


@mcp.tool()
async def unifi_sites() -> dict:
    """Sites.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "/api/self/sites")
    return _format_response(data)


@mcp.tool()
async def unifi_stat_admin() -> dict:
    """Stat Admin.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "/api/stat/admin")
    return _format_response(data)


@mcp.tool()
async def unifi_stat_sites() -> dict:
    """Stat Sites.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "/api/stat/sites")
    return _format_response(data)


@mcp.tool()
async def unifi_status() -> dict:
    """Status.

    No authentication required.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    # No auth required
    async with httpx.AsyncClient(
        base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
        verify=UNIFI_VERIFY_SSL,
        timeout=30.0,
    ) as c:
        resp = await c.request("GET", "/status")
        resp.raise_for_status()
        data = resp.json()
    return _format_response(data)


if not UNIFI_READ_ONLY:
    @mcp.tool()
    async def unifi_system_poweroff() -> dict:
        """System Poweroff.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "/api/system/poweroff")
        return _format_response(data)

if not UNIFI_READ_ONLY:
    @mcp.tool()
    async def unifi_system_reboot() -> dict:
        """System Reboot.

        If this tool returns an unexpected error, call unifi_report_issue to report it.
        """
        client = await _get_client()
        data = await client.request("POST", "/api/system/reboot")
        return _format_response(data)

# ===========================================================================
# Network Overview Tool (always-on, read-only)
# ===========================================================================


@mcp.tool()
async def unifi_get_overview(site: str = "") -> dict:
    """Get a concise network overview in a single call.

    Returns controller version, health status, device/network/WLAN summaries,
    client count, and active alarm count. Use this as a starting point before
    calling detailed tools.

    Args:
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    s = site or UNIFI_SITE

    health = await client.request("GET", "stat/health", site=s)
    devices = await client.request("GET", "stat/device", site=s)
    networks = await client.request("GET", "rest/networkconf", site=s)
    wlans = await client.request("GET", "rest/wlanconf", site=s)
    clients = await client.request("GET", "stat/sta", site=s)
    alarms = await client.request("GET", "stat/alarm", site=s)
    sysinfo = await client.request("GET", "stat/sysinfo", site=s)

    version = ""
    if sysinfo and isinstance(sysinfo, list) and sysinfo[0]:
        version = sysinfo[0].get("version", "")

    overview = {
        "controller_version": version,
        "health": {
            h.get("subsystem", "?"): h.get("status", "?")
            for h in health if isinstance(h, dict)
        },
        "device_summary": [
            {
                "name": d.get("name", ""),
                "type": d.get("type", ""),
                "model": d.get("model", ""),
                "mac": d.get("mac", ""),
                "status": "connected" if d.get("state") == 1 else "disconnected",
                "ip": d.get("ip", ""),
            }
            for d in devices if isinstance(d, dict)
        ],
        "network_summary": [
            {
                "name": n.get("name", ""),
                "purpose": n.get("purpose", ""),
                "subnet": n.get("ip_subnet", ""),
                "vlan": n.get("vlan", None),
                "enabled": n.get("enabled", True),
            }
            for n in networks if isinstance(n, dict)
        ],
        "wlan_summary": [
            {
                "name": w.get("name", ""),
                "security": w.get("security", ""),
                "enabled": w.get("enabled", True),
                "wpa_mode": w.get("wpa_mode", ""),
            }
            for w in wlans if isinstance(w, dict)
        ],
        "total_clients": len(clients) if isinstance(clients, list) else 0,
        "active_alarms": len([
            a for a in alarms
            if isinstance(a, dict) and not a.get("archived")
        ]) if isinstance(alarms, list) else 0,
    }
    return _format_response(overview, "Network overview")


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    mcp.run()
