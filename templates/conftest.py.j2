"""Pytest fixtures for UniFi controller integration tests (auto-generated).

DO NOT EDIT THIS FILE. All changes must be made in the generator.
"""

from __future__ import annotations

import os
import subprocess
import time

import httpx
import pytest

CONTROLLER_HOST = os.environ.get("UNIFI_HOST", "localhost")
CONTROLLER_PORT = int(os.environ.get("UNIFI_PORT", "8443"))
CONTROLLER_USERNAME = os.environ.get("UNIFI_USERNAME", "admin")
CONTROLLER_PASSWORD = os.environ.get("UNIFI_PASSWORD", "testpassword123")
CONTROLLER_SITE = os.environ.get("UNIFI_SITE", "default")
CONTAINER_NAME = os.environ.get("UNIFI_CONTAINER", "unifi-test-controller")
BASE_URL = f"https://{CONTROLLER_HOST}:{CONTROLLER_PORT}"


@pytest.fixture(scope="session")
def controller_url() -> str:
    """Wait for the UniFi controller to be ready, return base URL."""
    url = BASE_URL
    deadline = time.time() + 180  # 3 minutes max
    while time.time() < deadline:
        try:
            resp = httpx.get(f"{url}/status", verify=False, timeout=5.0)
            if resp.status_code == 200:
                return url
        except (httpx.ConnectError, httpx.ReadTimeout, httpx.ConnectTimeout):
            pass
        time.sleep(3)
    pytest.fail(f"Controller at {url} did not become ready within 180s")


def _try_login(base_url: str) -> bool:
    """Attempt login and return True if successful."""
    try:
        with httpx.Client(base_url=base_url, verify=False, timeout=10.0) as client:
            resp = client.post(
                "/api/login",
                json={"username": CONTROLLER_USERNAME, "password": CONTROLLER_PASSWORD},
            )
            return resp.status_code == 200
    except Exception:
        return False


def _seed_admin_via_mongodb() -> None:
    """Seed an admin user directly into UniFi's embedded MongoDB."""
    # Determine which mongo shell is available
    mongo_cmd = "mongo"
    try:
        result = subprocess.run(
            ["docker", "exec", CONTAINER_NAME, "which", "mongosh"],
            capture_output=True, timeout=10,
        )
        if result.returncode == 0:
            mongo_cmd = "mongosh"
    except Exception:
        pass

    # Wait for MongoDB to be ready
    for _ in range(30):
        try:
            result = subprocess.run(
                ["docker", "exec", CONTAINER_NAME, mongo_cmd, "--port", "27117",
                 "--quiet", "--eval", "db.runCommand({ping:1})", "ace"],
                capture_output=True, timeout=10,
            )
            if result.returncode == 0:
                break
        except Exception:
            pass
        time.sleep(2)

    # Generate password hash using openssl inside the container
    hash_result = subprocess.run(
        ["docker", "exec", CONTAINER_NAME, "openssl", "passwd", "-6", CONTROLLER_PASSWORD],
        capture_output=True, text=True, timeout=10,
    )
    if hash_result.returncode != 0:
        # Fallback: generate hash via Python inside the container
        hash_result = subprocess.run(
            ["docker", "exec", CONTAINER_NAME, "python3", "-c",
             f"import crypt; print(crypt.crypt('{CONTROLLER_PASSWORD}', crypt.mksalt(crypt.METHOD_SHA512)))"],
            capture_output=True, text=True, timeout=10,
        )
    password_hash = hash_result.stdout.strip()
    if not password_hash:
        raise RuntimeError("Failed to generate password hash")

{% raw %}
    # Seed admin into MongoDB
    mongo_script = f"""
var existing = db.admin.findOne({{"name": "{CONTROLLER_USERNAME}"}});
if (!existing) {{
    db.admin.insertOne({{
        "email": "admin@test.local",
        "last_site_name": "default",
        "name": "{CONTROLLER_USERNAME}",
        "x_shadow": "{password_hash}"
    }});
    var admin = db.admin.findOne({{"name": "{CONTROLLER_USERNAME}"}});
    var adminId = admin._id.toString();
    var sites = db.site.find().toArray();
    sites.forEach(function(site) {{
        db.privilege.insertOne({{
            "admin_id": adminId,
            "site_id": site._id.toString(),
            "role": "admin",
            "permissions": []
        }});
    }});
    print("Admin created: " + adminId);
}} else {{
    print("Admin already exists");
}}
"""
{% endraw %}
    result = subprocess.run(
        ["docker", "exec", "-i", CONTAINER_NAME, mongo_cmd, "--port", "27117",
         "--quiet", "ace"],
        input=mongo_script, capture_output=True, text=True, timeout=30,
    )
    if result.returncode != 0:
        print(f"MongoDB seed stderr: {result.stderr}")


@pytest.fixture(scope="session")
def setup_controller(controller_url: str) -> None:
    """Ensure the controller has an admin user we can log in with."""
    if _try_login(controller_url):
        return  # Already set up and login works

    # Seed admin directly into MongoDB
    _seed_admin_via_mongodb()

    # Wait for controller to recognize the new admin
    for _ in range(10):
        time.sleep(2)
        if _try_login(controller_url):
            return

    pytest.fail("Could not set up admin user for controller")


class AuthenticatedClient:
    """Wrapper around httpx.Client with UniFi auth."""

    def __init__(self, base_url: str, username: str, password: str) -> None:
        self.client = httpx.Client(base_url=base_url, verify=False, timeout=30.0)
        self.base_url = base_url
        self.username = username
        self.password = password
        self.csrf_token: str | None = None
        self.site = CONTROLLER_SITE

    def login(self) -> None:
        resp = self.client.post(
            "/api/login",
            json={"username": self.username, "password": self.password},
        )
        resp.raise_for_status()
        self.csrf_token = resp.cookies.get("csrf_token") or resp.headers.get("x-csrf-token")

    def logout(self) -> None:
        try:
            self.client.post("/api/logout")
        except Exception:
            pass

    def _headers(self) -> dict[str, str]:
        headers = {}
        if self.csrf_token:
            headers["x-csrf-token"] = self.csrf_token
        return headers

    def api_get(self, path: str) -> dict | list:
        full_path = f"/api/s/{self.site}/{path}"
        resp = self.client.get(full_path, headers=self._headers())
        resp.raise_for_status()
        return self._parse(resp)

    def api_post(self, path: str, data: dict | None = None) -> dict | list:
        full_path = f"/api/s/{self.site}/{path}"
        resp = self.client.post(full_path, json=data or {}, headers=self._headers())
        resp.raise_for_status()
        return self._parse(resp)

    def api_put(self, path: str, data: dict) -> dict | list:
        full_path = f"/api/s/{self.site}/{path}"
        resp = self.client.put(full_path, json=data, headers=self._headers())
        resp.raise_for_status()
        return self._parse(resp)

    def api_delete(self, path: str) -> dict | list:
        full_path = f"/api/s/{self.site}/{path}"
        resp = self.client.delete(full_path, headers=self._headers())
        resp.raise_for_status()
        return self._parse(resp)

    def v2_get(self, path: str) -> dict | list:
        full_path = f"/{path}".replace("{site}", self.site)
        resp = self.client.get(full_path, headers=self._headers())
        resp.raise_for_status()
        return resp.json()

    def v2_post(self, path: str, data: dict) -> dict | list:
        full_path = f"/{path}".replace("{site}", self.site)
        resp = self.client.post(full_path, json=data, headers=self._headers())
        resp.raise_for_status()
        return resp.json()

    def v2_put(self, path: str, data: dict) -> dict | list:
        full_path = f"/{path}".replace("{site}", self.site)
        resp = self.client.put(full_path, json=data, headers=self._headers())
        resp.raise_for_status()
        return resp.json()

    def v2_delete(self, path: str) -> dict | list:
        full_path = f"/{path}".replace("{site}", self.site)
        resp = self.client.delete(full_path, headers=self._headers())
        resp.raise_for_status()
        return resp.json()

    def global_get(self, path: str) -> dict | list:
        resp = self.client.get(path, headers=self._headers())
        resp.raise_for_status()
        return resp.json()

    def _parse(self, resp: httpx.Response) -> dict | list:
        data = resp.json()
        if isinstance(data, dict) and "meta" in data:
            if data["meta"].get("rc") != "ok":
                msg = data["meta"].get("msg", "Unknown error")
                raise RuntimeError(f"UniFi API error: {msg}")
            return data.get("data", [])
        return data

    def close(self) -> None:
        self.logout()
        self.client.close()


@pytest.fixture(scope="session")
def authenticated_client(
    controller_url: str,
    setup_controller: None,
) -> AuthenticatedClient:
    """Provide an authenticated API client for the test session."""
    client = AuthenticatedClient(
        base_url=controller_url,
        username=CONTROLLER_USERNAME,
        password=CONTROLLER_PASSWORD,
    )
    client.login()
    yield client
    client.close()


@pytest.fixture(scope="session")
def default_network_id(authenticated_client: AuthenticatedClient) -> str:
    """Get the _id of the default LAN network."""
    data = authenticated_client.api_get("rest/networkconf")
    for net in data:
        if isinstance(net, dict) and net.get("name") == "Default":
            return net["_id"]
    # Return the first network if no 'Default' found
    if data and isinstance(data[0], dict):
        return data[0]["_id"]
    pytest.skip("No default network found")
