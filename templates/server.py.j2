"""UniFi Network Controller MCP Server (auto-generated).

Generated from controller version {{ controller_version }}.
Total tools: ~{{ tool_count }}

DO NOT EDIT THIS FILE. All changes must be made in the generator.
"""

from __future__ import annotations

import json
import os
import re
from typing import Any

import httpx
from fastmcp import FastMCP

mcp = FastMCP("UniFi Network Controller")

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

UNIFI_HOST = os.environ.get("UNIFI_HOST", "localhost")
UNIFI_PORT = int(os.environ.get("UNIFI_PORT", "8443"))
UNIFI_USERNAME = os.environ.get("UNIFI_USERNAME", "admin")
UNIFI_PASSWORD = os.environ.get("UNIFI_PASSWORD", "")
UNIFI_SITE = os.environ.get("UNIFI_SITE", "default")
UNIFI_VERIFY_SSL = os.environ.get("UNIFI_VERIFY_SSL", "false").lower() == "true"
UNIFI_MODULES = set(
    m.strip() for m in os.environ.get("UNIFI_MODULES", "v1,v2").split(",") if m.strip()
)


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------


class UniFiClient:
    """Handles authentication, session cookies, and CSRF tokens."""

    def __init__(self) -> None:
        self._client = httpx.AsyncClient(
            base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
            verify=UNIFI_VERIFY_SSL,
            timeout=30.0,
        )
        self._csrf_token: str | None = None
        self._logged_in = False

    async def login(self) -> None:
        resp = await self._client.post(
            "/api/login",
            json={"username": UNIFI_USERNAME, "password": UNIFI_PASSWORD},
        )
        resp.raise_for_status()
        # Extract CSRF token from cookies or response
        self._csrf_token = resp.cookies.get("csrf_token") or resp.headers.get("x-csrf-token")
        self._logged_in = True

    async def logout(self) -> None:
        if self._logged_in:
            try:
                await self._client.post("/api/logout")
            except Exception:
                pass
            self._logged_in = False

    async def _ensure_logged_in(self) -> None:
        if not self._logged_in:
            await self.login()

    async def request(
        self,
        method: str,
        path: str,
        json_data: dict | None = None,
        site: str | None = None,
    ) -> dict | list:
        """Make an authenticated API request. Auto-relogins on 401."""
        await self._ensure_logged_in()

        # Replace {site} placeholder in path
        effective_site = site or UNIFI_SITE
        full_path = path.replace("{site}", effective_site)

        # Ensure path starts with /
        if not full_path.startswith("/"):
            full_path = f"/api/s/{effective_site}/{full_path}"

        headers = {}
        if self._csrf_token:
            headers["x-csrf-token"] = self._csrf_token

        try:
            resp = await self._client.request(
                method, full_path, json=json_data, headers=headers,
            )
        except httpx.ConnectError:
            raise RuntimeError(
                f"Connection failed: cannot reach UniFi controller at "
                f"{UNIFI_HOST}:{UNIFI_PORT}. Check UNIFI_HOST and UNIFI_PORT."
            )
        except httpx.TimeoutException:
            raise RuntimeError(
                f"Request timed out: {method} {full_path}. "
                f"The controller at {UNIFI_HOST}:{UNIFI_PORT} may be overloaded or unreachable."
            )

        # Auto-relogin on 401
        if resp.status_code == 401:
            await self.login()
            if self._csrf_token:
                headers["x-csrf-token"] = self._csrf_token
            resp = await self._client.request(
                method, full_path, json=json_data, headers=headers,
            )

        if resp.status_code == 403:
            raise RuntimeError(
                f"Authentication failed (403 Forbidden): {method} {full_path}. "
                f"Check UNIFI_USERNAME and UNIFI_PASSWORD."
            )

        # Parse response body before raising for status â€” UniFi often
        # returns useful error details in the JSON body for 400/404/500.
        try:
            data = resp.json()
        except Exception:
            # Non-JSON response (empty body, HTML error page, etc.)
            if resp.status_code >= 400:
                raise RuntimeError(
                    f"HTTP {resp.status_code} on {method} {full_path} "
                    f"(non-JSON response, {len(resp.content)} bytes). "
                    f"Controller may still be starting up."
                )
            resp.raise_for_status()
            return []

        # v1 API envelope
        if isinstance(data, dict) and "meta" in data:
            if data["meta"].get("rc") != "ok":
                msg = data["meta"].get("msg", "Unknown error")
                raise RuntimeError(f"UniFi API error on {method} {full_path}: {msg}")
            return data.get("data", [])

        # For non-envelope errors (v2 API, raw error objects)
        if resp.status_code >= 400:
            if isinstance(data, dict):
                # Try common error fields
                msg = data.get("message") or data.get("error") or data.get("msg") or str(data)
            else:
                msg = str(data)
            raise RuntimeError(f"HTTP {resp.status_code} on {method} {full_path}: {msg}")

        return data

    async def close(self) -> None:
        await self.logout()
        await self._client.aclose()


# Singleton client
_client = UniFiClient()


async def _get_client() -> UniFiClient:
    return _client


# ---------------------------------------------------------------------------
# Helper: format response
# ---------------------------------------------------------------------------

def _format_response(data: Any, summary: str | None = None) -> str:
    """Format API response data for tool output."""
    if summary:
        return f"{summary}\n\n{json.dumps(data, indent=2, default=str)}"
    return json.dumps(data, indent=2, default=str)


_MAC_RE = re.compile(r"^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$")


def _validate_mac(mac: str) -> str | None:
    """Return an error message if MAC format is invalid, else None."""
    if not _MAC_RE.match(mac):
        return f"Invalid MAC address format: '{mac}'. Expected format: XX:XX:XX:XX:XX:XX (hex pairs separated by colons)."
    return None


# ===========================================================================
# Error Reporting Tool (always-on)
# ===========================================================================


@mcp.tool()
async def unifi_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: dict[str, Any],
    notes: str = "",
) -> str:
    """Report an unexpected UniFi MCP tool error by composing a GitHub issue command.

    This tool does NOT make any HTTP calls. It returns a ready-to-paste
    `gh issue create` command that the user can review and run to file a bug report.

    Args:
        tool_name: The MCP tool that produced the error (e.g. unifi_create_network).
        error_message: The error message or response body returned by the tool.
        parameters_used: The parameters that were passed to the failing tool call.
        notes: Any additional context about what you were trying to accomplish.
    """
    import json as _json

    params_block = _json.dumps(parameters_used, indent=2, default=str)
    notes_section = f"\n\n## Notes\n\n{notes}" if notes else ""

    body = (
        f"## Tool\n\n`{tool_name}`\n\n"
        f"## Error\n\n```\n{error_message}\n```\n\n"
        f"## Parameters\n\n```json\n{params_block}\n```\n\n"
        f"## Repro Steps\n\n"
        f"1. Call `{tool_name}` with the parameters above\n"
        f"2. Observe the error response"
        f"{notes_section}"
    )

    escaped_body = body.replace("'", "'\\''")
    escaped_title = f"Bug: {tool_name} returns unexpected error".replace("'", "'\\''")

    return (
        f"Run this command to file the issue:\n\n"
        f"gh issue create --repo abl030/unifi-mcp "
        f"--label bug --label mcp-reported "
        f"--title '{escaped_title}' "
        f"--body '{escaped_body}'"
    )

{# ======================================================================= #}
{# MACROS: Per-tool rendering for each tool type                           #}
{# ======================================================================= #}
{% macro render_rest_tool(tool) %}
{% if tool.is_setting %}

# --- Settings (special handling: keyed by 'key' field) ---

@mcp.tool()
async def unifi_list_settings(site: str = "") -> str:
    """List all site settings. Returns all setting categories.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "rest/setting", site=site or None)
    return _format_response(data, f"Found {len(data)} setting categories")


@mcp.tool()
async def unifi_get_setting(key: str, site: str = "") -> str:
    """Get a specific site setting by key (e.g. 'super_identity', 'snmp').

    Args:
        key: The setting key to retrieve.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "rest/setting", site=site or None)
    for item in data:
        if isinstance(item, dict) and item.get("key") == key:
            return _format_response(item)
    return _format_response(None, f"Setting '{key}' not found")


@mcp.tool()
async def unifi_update_setting(
    key: str,
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Update a site setting by key.

    Args:
        key: The setting key to update (e.g. 'mgmt', 'snmp', 'ntp', 'locale').
        data: Fields to update. Read current values first with unifi_get_setting.
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "update_setting", "key": key, "data": data},
            "DRY RUN (PUT set/setting/{key}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("PUT", f"set/setting/{key}", json_data=data, site=site or None)
    return _format_response(result, f"Updated setting '{key}'")

{% elif tool.is_readonly %}

# --- {{ tool.singular | title }} (read-only) ---

@mcp.tool()
async def unifi_list_{{ tool.plural }}(site: str = "") -> str:
    """List all {{ tool.plural }}.

    Returns {{ tool.plural }} from the UniFi controller.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "{{ tool.path }}", site=site or None)
    return _format_response(data, f"Found {len(data)} {{ tool.plural }}")

{% elif tool.is_crud %}

# --- {{ tool.singular | title }} CRUD ---

@mcp.tool()
async def unifi_list_{{ tool.plural }}(site: str = "") -> str:
    """List all {{ tool.plural }}.
{% if tool.writable_fields %}

    Key fields: {{ tool.writable_fields[:8] | map(attribute='description') | join(', ') }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "{{ tool.path }}", site=site or None)
    return _format_response(data, f"Found {len(data)} {{ tool.plural }}")


@mcp.tool()
async def unifi_get_{{ tool.singular }}(id: str, site: str = "") -> str:
    """Get a single {{ tool.singular }} by ID.

    Args:
        id: The _id of the {{ tool.singular }}.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "{{ tool.path }}/{id}".format(id=id), site=site or None)
    if isinstance(data, list) and len(data) == 1:
        return _format_response(data[0])
    return _format_response(data)


@mcp.tool()
async def unifi_create_{{ tool.singular }}(
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Create a new {{ tool.singular }}.

    Args:
        data: {{ tool.singular | title }} configuration.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% elif tool.required_create_fields %}
            {{ tool.required_create_fields }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).
{% if tool.workflow_hint %}

    {{ tool.workflow_hint }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "create_{{ tool.singular }}", "data": data},
            "DRY RUN (POST {{ tool.path }}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("POST", "{{ tool.path }}", json_data=data, site=site or None)
    return _format_response(result, "Created {{ tool.singular }}")


@mcp.tool()
async def unifi_update_{{ tool.singular }}(
    id: str,
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Update an existing {{ tool.singular }}.

    Args:
        id: The _id of the {{ tool.singular }} to update.
        data: Fields to update.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).
{% if tool.full_object_update %}

    Note: This resource requires sending the FULL object on update, not just changed fields.
    First GET the current object, modify the fields you want, then send the complete object.
{% endif %}
{% if tool.workflow_hint %}

    {{ tool.workflow_hint }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "update_{{ tool.singular }}", "id": id, "data": data},
            "DRY RUN (PUT {{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("PUT", "{{ tool.path }}/{id}".format(id=id), json_data=data, site=site or None)
    return _format_response(result, "Updated {{ tool.singular }}")


{% if not tool.no_rest_delete %}
@mcp.tool()
async def unifi_delete_{{ tool.singular }}(
    id: str,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Delete a {{ tool.singular }}.

    Args:
        id: The _id of the {{ tool.singular }} to delete.
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "delete_{{ tool.singular }}", "id": id},
            "DRY RUN (DELETE {{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("DELETE", "{{ tool.path }}/{id}".format(id=id), site=site or None)
    return _format_response(result, "Deleted {{ tool.singular }}")

{% endif %}
{% endif %}
{% endmacro %}
{% macro render_stat_tool(tool) %}
{% if tool.resource == "report" %}

@mcp.tool()
async def unifi_list_report(
    interval: str = "hourly",
    report_type: str = "site",
    site: str = "",
) -> str:
    """Get statistical reports.

    Args:
        interval: Report interval: '5minutes', 'hourly', or 'daily'.
        report_type: Report type: 'site', 'user', 'ap'.
        site: Site name (default: from env).

    Note: {{ tool.note }}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    path = f"stat/report/{interval}.{report_type}"
    data = await client.request("POST", path, json_data={}, site=site or None)
    return _format_response(data, f"Found {len(data)} report records")

{% else %}

@mcp.tool()
async def unifi_list_{{ tool.display_name }}(site: str = "") -> str:
    """List {{ tool.display_name }} statistics.
{% if tool.note %}

    Note: {{ tool.note }}
{% endif %}
{% if tool.sample_fields %}

    Key fields: {{ tool.sample_fields | join(', ') }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
{% if tool.method == "POST" %}
    data = await client.request("POST", "{{ tool.path }}", json_data={{ tool.post_body }}, site=site or None)
{% else %}
    data = await client.request("GET", "{{ tool.path }}", site=site or None)
{% endif %}
    return _format_response(data, f"Found {len(data)} {{ tool.display_name }} records")

{% endif %}
{% endmacro %}
{% macro render_cmd_tool(tool) %}

@mcp.tool()
async def unifi_{{ tool.tool_name }}(
{% for pname, ptype in tool.params.items() %}
{% if pname == "site" %}
    target_site: {{ ptype }},
{% else %}
    {{ pname }}: {{ ptype }},
{% endif %}
{% endfor %}
{% if tool.is_mutation %}
    confirm: bool = False,
{% endif %}
    site: str = "",
) -> str:
    """Execute '{{ tool.command }}' via {{ tool.manager }}.

{% for pname, ptype in tool.params.items() %}
    Args:
{% if pname == "site" %}
        target_site: Target site for the command ({{ ptype }}).
{% else %}
        {{ pname }}: {{ pname }} parameter ({{ ptype }}).
{% endif %}
{% endfor %}
{% if tool.is_mutation %}
        confirm: Must be True to execute. Returns preview if False.
{% endif %}
        site: Site name override (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
{% if tool.is_mutation %}
    if not confirm:
        preview = {"action": "{{ tool.tool_name }}", "cmd": "{{ tool.command }}"}
{% for pname, ptype in tool.params.items() %}
{% if pname == "site" %}
        preview["site"] = target_site
{% else %}
        preview["{{ pname }}"] = {{ pname }}
{% endif %}
{% endfor %}
        return _format_response(
            preview,
            "DRY RUN (POST {{ tool.path }}): Set confirm=True to execute.",
        )
{% endif %}
{% if "mac" in tool.params %}
    mac_err = _validate_mac(mac)
    if mac_err:
        return _format_response({"error": mac_err}, mac_err)
{% endif %}
    payload: dict[str, Any] = {"cmd": "{{ tool.command }}"}
{% for pname, ptype in tool.params.items() %}
{% if pname == "site" %}
    payload["site"] = target_site
{% else %}
    payload["{{ pname }}"] = {{ pname }}
{% endif %}
{% endfor %}
    client = await _get_client()
    result = await client.request("POST", "{{ tool.path }}", json_data=payload, site=site or None)
    return _format_response(result, "Executed {{ tool.command }}")

{% endmacro %}
{% macro render_v2_tool(tool) %}

# --- v2: {{ tool.singular | title }} ---
{% if "GET" in tool.methods %}

@mcp.tool()
async def unifi_list_{{ tool.plural }}(site: str = "") -> str:
    """List all {{ tool.plural }} (v2 API).
{% if tool.writable_fields %}

    Key fields: {{ tool.writable_fields[:8] | map(attribute='description') | join(', ') }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    data = await client.request("GET", "/{{ tool.path }}".replace("{site}", effective_site))
    if isinstance(data, list):
        return _format_response(data, f"Found {len(data)} {{ tool.plural }}")
    return _format_response(data)

{% endif %}
{% if "POST" in tool.methods %}

@mcp.tool()
async def unifi_create_{{ tool.singular }}(
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Create a new {{ tool.singular }} (v2 API).

    Args:
        data: {{ tool.singular | title }} configuration.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% elif tool.create_hint %}
            {{ tool.create_hint }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "create_{{ tool.singular }}", "data": data},
            "DRY RUN (POST /{{ tool.path }}): Set confirm=True to execute.",
        )
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    result = await client.request("POST", "/{{ tool.path }}".replace("{site}", effective_site), json_data=data)
    return _format_response(result, "Created {{ tool.singular }}")

{% endif %}
{% if "PUT" in tool.methods %}

@mcp.tool()
async def unifi_update_{{ tool.singular }}(
    id: str,
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Update a {{ tool.singular }} (v2 API).

    Args:
        id: The ID of the {{ tool.singular }} to update.
        data: The FULL {{ tool.singular }} object with your changes applied.
            v2 API requires sending the complete object, not just changed fields.
            First GET the current object, modify the fields you want, then send the full object.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "update_{{ tool.singular }}", "id": id, "data": data},
            "DRY RUN (PUT /{{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    result = await client.request("PUT", "/{{ tool.path }}/{id}".replace("{site}", effective_site).format(id=id), json_data=data)
    return _format_response(result, "Updated {{ tool.singular }}")

{% endif %}
{% if "DELETE" in tool.methods %}

@mcp.tool()
async def unifi_delete_{{ tool.singular }}(
    id: str,
    confirm: bool = False,
    site: str = "",
) -> str:
    """Delete a {{ tool.singular }} (v2 API).

    Args:
        id: The ID of the {{ tool.singular }} to delete.
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "delete_{{ tool.singular }}", "id": id},
            "DRY RUN (DELETE /{{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    result = await client.request("DELETE", "/{{ tool.path }}/{id}".replace("{site}", effective_site).format(id=id))
    return _format_response(result, "Deleted {{ tool.singular }}")

{% endif %}
{% endmacro %}

{% for mod in module_order %}
{% set mod_rest = rest_by_module.get(mod, []) %}
{% set mod_stat = stat_by_module.get(mod, []) %}
{% set mod_cmd = cmd_by_module.get(mod, []) %}
{% set mod_v2 = v2_by_module.get(mod, []) %}
{% if mod_rest or mod_stat or mod_cmd or mod == "device" %}

if "{{ mod }}" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
{% filter indent(4, first=True) %}
# ===========================================================================
# Module: {{ mod }}
# ===========================================================================
{% for tool in mod_rest %}
{{ render_rest_tool(tool) }}
{% endfor %}
{% for tool in mod_stat %}
{{ render_stat_tool(tool) }}
{% endfor %}
{% for tool in mod_cmd %}
{{ render_cmd_tool(tool) }}
{% endfor %}
{% if mod == "device" %}

# ===========================================================================
# Special: Port Override Helper
# ===========================================================================

@mcp.tool()
async def unifi_set_port_override(
    device_id: str,
    port_idx: int,
    portconf_id: str = "",
    name: str = "",
    native_networkconf_id: str = "",
    forward: str = "",
    poe_mode: str = "",
    confirm: bool = False,
    site: str = "",
) -> str:
    """Set port override on a device (switch port configuration).

    This updates a specific port on a UniFi switch device.

    Args:
        device_id: The _id of the device.
        port_idx: Port number (1-based).
        portconf_id: Port profile ID to apply (from rest/portconf).
        name: Custom port name.
        native_networkconf_id: Network ID for native VLAN.
        forward: Forward mode ('all', 'customize', 'disabled').
        poe_mode: PoE mode ('auto', 'off', 'pasv24', 'passthrough').
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    override: dict[str, Any] = {"port_idx": port_idx}
    if portconf_id:
        override["portconf_id"] = portconf_id
    if name:
        override["name"] = name
    if native_networkconf_id:
        override["native_networkconf_id"] = native_networkconf_id
    if forward:
        override["forward"] = forward
    if poe_mode:
        override["poe_mode"] = poe_mode

    if not confirm:
        return _format_response(
            {"action": "set_port_override", "device_id": device_id, "override": override},
            "DRY RUN (PUT rest/device/{device_id}): Set confirm=True to execute.",
        )

    client = await _get_client()
    # First get current device to preserve existing overrides
    device_data = await client.request("GET", f"rest/device/{device_id}", site=site or None)
    if isinstance(device_data, list) and device_data:
        device_data = device_data[0]

    existing_overrides = []
    if isinstance(device_data, dict):
        existing_overrides = device_data.get("port_overrides", [])

    # Replace or append override for this port_idx
    new_overrides = [o for o in existing_overrides if o.get("port_idx") != port_idx]
    new_overrides.append(override)

    result = await client.request(
        "PUT",
        f"rest/device/{device_id}",
        json_data={"port_overrides": new_overrides},
        site=site or None,
    )
    return _format_response(result, f"Set port override on port {port_idx}")

{% endif %}
{% endfilter %}
{% endif %}
{% if mod_v2 %}

if "{{ mod }}" in UNIFI_MODULES or "v2" in UNIFI_MODULES:
{% filter indent(4, first=True) %}
{% for tool in mod_v2 %}
{{ render_v2_tool(tool) }}
{% endfor %}
{% endfilter %}
{% endif %}
{% endfor %}

# ===========================================================================
# Global Endpoint Tools (always-on)
# ===========================================================================
{% for tool in global_tools %}

@mcp.tool()
async def unifi_{{ tool.name }}({{ 'site: str = ""' if '{site}' in tool.path else '' }}) -> str:
    """{{ tool.name | replace('_', ' ') | title }}.
{% if not tool.auth %}

    No authentication required.
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
{% if tool.auth %}
    client = await _get_client()
    data = await client.request("{{ tool.method }}", "{{ tool.path }}")
{% else %}
    # No auth required
    async with httpx.AsyncClient(
        base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
        verify=UNIFI_VERIFY_SSL,
        timeout=30.0,
    ) as c:
        resp = await c.request("{{ tool.method }}", "{{ tool.path }}")
        resp.raise_for_status()
        data = resp.json()
{% endif %}
    return _format_response(data)

{% endfor %}

# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    mcp.run()
