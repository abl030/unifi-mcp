"""UniFi Network Controller MCP Server (auto-generated).

Generated from controller version {{ controller_version }}.
Total tools: ~{{ tool_count }}

DO NOT EDIT THIS FILE. All changes must be made in the generator.
"""

from __future__ import annotations

import json
import os
import re
from typing import Any

import httpx
from fastmcp import FastMCP

mcp = FastMCP(
    "UniFi Network Controller",
    instructions=(
        "This server has {{ tool_count }} tools. "
        "Call unifi_search_tools first to find relevant tools by keyword "
        "(e.g. 'vlan', 'firewall rule', 'backup') instead of scanning all tool signatures. "
        "If a tool returns an unexpected error, call unifi_report_issue to report it."
    ),
)

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

UNIFI_HOST = os.environ.get("UNIFI_HOST", "localhost")
UNIFI_PORT = int(os.environ.get("UNIFI_PORT", "8443"))
UNIFI_USERNAME = os.environ.get("UNIFI_USERNAME", "admin")
UNIFI_PASSWORD = os.environ.get("UNIFI_PASSWORD", "")
UNIFI_SITE = os.environ.get("UNIFI_SITE", "default")
UNIFI_VERIFY_SSL = os.environ.get("UNIFI_VERIFY_SSL", "false").lower() == "true"
UNIFI_MODULES = set(
    m.strip() for m in os.environ.get("UNIFI_MODULES", "v1,v2").split(",") if m.strip()
)
UNIFI_READ_ONLY = os.environ.get("UNIFI_READ_ONLY", "false").lower() == "true"
UNIFI_REDACT_SECRETS = os.environ.get("UNIFI_REDACT_SECRETS", "true").lower() != "false"


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------


class UniFiClient:
    """Handles authentication, session cookies, and CSRF tokens."""

    def __init__(self) -> None:
        self._client = httpx.AsyncClient(
            base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
            verify=UNIFI_VERIFY_SSL,
            timeout=30.0,
        )
        self._csrf_token: str | None = None
        self._logged_in = False

    async def login(self) -> None:
        resp = await self._client.post(
            "/api/login",
            json={"username": UNIFI_USERNAME, "password": UNIFI_PASSWORD},
        )
        resp.raise_for_status()
        # Extract CSRF token from cookies or response
        self._csrf_token = resp.cookies.get("csrf_token") or resp.headers.get("x-csrf-token")
        self._logged_in = True

    async def logout(self) -> None:
        if self._logged_in:
            try:
                await self._client.post("/api/logout")
            except Exception:
                pass
            self._logged_in = False

    async def _ensure_logged_in(self) -> None:
        if not self._logged_in:
            await self.login()

    async def request(
        self,
        method: str,
        path: str,
        json_data: dict | None = None,
        site: str | None = None,
    ) -> dict | list:
        """Make an authenticated API request. Auto-relogins on 401."""
        await self._ensure_logged_in()

        # Replace {site} placeholder in path
        effective_site = site or UNIFI_SITE
        full_path = path.replace("{site}", effective_site)

        # Ensure path starts with /
        if not full_path.startswith("/"):
            full_path = f"/api/s/{effective_site}/{full_path}"

        headers = {}
        if self._csrf_token:
            headers["x-csrf-token"] = self._csrf_token

        try:
            resp = await self._client.request(
                method, full_path, json=json_data, headers=headers,
            )
        except httpx.ConnectError:
            raise RuntimeError(
                f"Connection failed: cannot reach UniFi controller at "
                f"{UNIFI_HOST}:{UNIFI_PORT}. Check UNIFI_HOST and UNIFI_PORT."
            )
        except httpx.TimeoutException:
            raise RuntimeError(
                f"Request timed out: {method} {full_path}. "
                f"The controller at {UNIFI_HOST}:{UNIFI_PORT} may be overloaded or unreachable."
            )

        # Auto-relogin on 401
        if resp.status_code == 401:
            await self.login()
            if self._csrf_token:
                headers["x-csrf-token"] = self._csrf_token
            resp = await self._client.request(
                method, full_path, json=json_data, headers=headers,
            )

        if resp.status_code == 403:
            raise RuntimeError(
                f"Authentication failed (403 Forbidden): {method} {full_path}. "
                f"Check UNIFI_USERNAME and UNIFI_PASSWORD."
            )

        # Parse response body before raising for status â€” UniFi often
        # returns useful error details in the JSON body for 400/404/500.
        try:
            data = resp.json()
        except Exception:
            # Non-JSON response (empty body, HTML error page, etc.)
            if resp.status_code >= 400:
                raise RuntimeError(
                    f"HTTP {resp.status_code} on {method} {full_path} "
                    f"(non-JSON response, {len(resp.content)} bytes). "
                    f"Controller may still be starting up."
                )
            resp.raise_for_status()
            return []

        # v1 API envelope
        if isinstance(data, dict) and "meta" in data:
            if data["meta"].get("rc") != "ok":
                msg = data["meta"].get("msg", "Unknown error")
                raise RuntimeError(f"UniFi API error on {method} {full_path}: {msg}")
            return data.get("data", [])

        # For non-envelope errors (v2 API, raw error objects)
        if resp.status_code >= 400:
            if isinstance(data, dict):
                # Try common error fields
                msg = data.get("message") or data.get("error") or data.get("msg") or str(data)
            else:
                msg = str(data)
            raise RuntimeError(f"HTTP {resp.status_code} on {method} {full_path}: {msg}")

        return data

    async def close(self) -> None:
        await self.logout()
        await self._client.aclose()


# Singleton client
_client = UniFiClient()


async def _get_client() -> UniFiClient:
    return _client


# ---------------------------------------------------------------------------
# Helper: secret redaction
# ---------------------------------------------------------------------------

_REDACT_FIELDS = frozenset({
    "x_passphrase", "x_iapp_key", "x_password", "x_shadow",
    "x_private_key", "x_certificate_pem", "x_certificate_arn",
    "x_api_token", "x_mgmt_key", "x_secret", "x_psk",
    "x_mesh_psk", "x_element_psk",
})
_REDACT_SUBSTRINGS = ("password", "passphrase", "secret", "preshared_key")


def _redact_secrets(obj: Any) -> Any:
    """Recursively replace sensitive field values with '<redacted>'."""
    if isinstance(obj, dict):
        return {
            k: "<redacted>" if (k in _REDACT_FIELDS or any(s in k.lower() for s in _REDACT_SUBSTRINGS)) else _redact_secrets(v)
            for k, v in obj.items()
        }
    if isinstance(obj, list):
        return [_redact_secrets(item) for item in obj]
    return obj


# ---------------------------------------------------------------------------
# Helper: format response
# ---------------------------------------------------------------------------

def _format_response(
    data: Any,
    summary: str | None = None,
    missing_fields: list[str] | None = None,
) -> dict:
    """Format API response data as structured dict for tool output."""
    if UNIFI_REDACT_SECRETS:
        data = _redact_secrets(data)
    result: dict[str, Any] = {}
    if summary:
        result["summary"] = summary
    if isinstance(data, list):
        result["count"] = len(data)
        result["data"] = data
    elif data is not None:
        result["data"] = data
    if missing_fields:
        result["missing_fields"] = missing_fields
    return result


# ---------------------------------------------------------------------------
# Helper: pagination and field selection
# ---------------------------------------------------------------------------

def _paginate_and_filter(
    data: list, limit: int, offset: int, fields: str
) -> tuple[list, list[str]]:
    """Apply offset, limit, and field selection to a list of records.

    Returns (filtered_data, missing_fields) where missing_fields lists any
    requested field names that don't exist in the data.
    """
    if offset:
        data = data[offset:]
    if limit:
        data = data[:limit]
    missing: list[str] = []
    if fields:
        field_set = {f.strip() for f in fields.split(",")}
        field_set.add("_id")  # always include _id for reference
        # Detect fields that don't exist in any record
        if data:
            available: set[str] = set()
            for item in data:
                if isinstance(item, dict):
                    available.update(item.keys())
            missing = sorted(field_set - available - {"_id"})
        data = [
            {k: v for k, v in item.items() if k in field_set}
            for item in data if isinstance(item, dict)
        ]
    return data, missing


_MAC_RE = re.compile(r"^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$")


def _validate_mac(mac: str) -> str | None:
    """Return an error message if MAC format is invalid, else None."""
    if not _MAC_RE.match(mac):
        return f"Invalid MAC address format: '{mac}'. Expected format: XX:XX:XX:XX:XX:XX (hex pairs separated by colons)."
    return None


# ===========================================================================
# Error Reporting Tool (always-on)
# ===========================================================================


@mcp.tool()
async def unifi_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: dict[str, Any],
    notes: str = "",
) -> dict:
    """Report an unexpected UniFi MCP tool error by composing a GitHub issue command.

    This tool does NOT make any HTTP calls. It returns a ready-to-paste
    `gh issue create` command that the user can review and run to file a bug report.

    Args:
        tool_name: The MCP tool that produced the error (e.g. unifi_create_network).
        error_message: The error message or response body returned by the tool.
        parameters_used: The parameters that were passed to the failing tool call.
        notes: Any additional context about what you were trying to accomplish.
    """
    import json as _json

    params_block = _json.dumps(parameters_used, indent=2, default=str)
    notes_section = f"\n\n## Notes\n\n{notes}" if notes else ""

    body = (
        f"## Tool\n\n`{tool_name}`\n\n"
        f"## Error\n\n```\n{error_message}\n```\n\n"
        f"## Parameters\n\n```json\n{params_block}\n```\n\n"
        f"## Repro Steps\n\n"
        f"1. Call `{tool_name}` with the parameters above\n"
        f"2. Observe the error response"
        f"{notes_section}"
    )

    escaped_body = body.replace("'", "'\\''")
    escaped_title = f"Bug: {tool_name} returns unexpected error".replace("'", "'\\''")

    return (
        f"Run this command to file the issue:\n\n"
        f"gh issue create --repo abl030/unifi-mcp "
        f"--label bug --label mcp-reported "
        f"--title '{escaped_title}' "
        f"--body '{escaped_body}'"
    )

{# ======================================================================= #}
{# MACROS: Per-tool rendering for each tool type                           #}
{# ======================================================================= #}
{% macro render_rest_tool(tool) %}
{% if tool.is_setting %}

# --- Settings (special handling: keyed by 'key' field) ---

@mcp.tool()
async def unifi_list_settings(
    site: str = "",
    limit: int = 0,
    offset: int = 0,
    fields: str = "",
) -> dict:
    """List all site settings. Returns all setting categories.

    Args:
        site: Site name (default: from env).
        limit: Max records to return (0 = all).
        offset: Number of records to skip.
        fields: Comma-separated field names to include (e.g. 'key,name'). Always includes _id.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "rest/setting", site=site or None)
    total = len(data)
    data, missing = _paginate_and_filter(data, limit, offset, fields)
    return _format_response(data, f"Found {total} setting categories", missing_fields=missing)


@mcp.tool()
async def unifi_get_setting(key: str, site: str = "") -> dict:
    """Get a specific site setting by key (e.g. 'super_identity', 'snmp').

    Args:
        key: The setting key to retrieve.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "rest/setting", site=site or None)
    for item in data:
        if isinstance(item, dict) and item.get("key") == key:
            return _format_response(item)
    return _format_response(None, f"Setting '{key}' not found")

if not UNIFI_READ_ONLY:
{% filter indent(4, first=True) %}

@mcp.tool()
async def unifi_update_setting(
    key: str,
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Update a site setting by key.

    Args:
        key: The setting key to update (e.g. 'mgmt', 'snmp', 'ntp', 'locale').
        data: Fields to update. Read current values first with unifi_get_setting.
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "update_setting", "key": key, "data": data},
            "DRY RUN (PUT set/setting/{key}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("PUT", f"set/setting/{key}", json_data=data, site=site or None)
    return _format_response(result, f"Updated setting '{key}'")
{% endfilter %}

{% elif tool.is_readonly %}

# --- {{ tool.singular | title }} (read-only) ---

@mcp.tool()
async def unifi_list_{{ tool.plural }}(
    site: str = "",
    limit: int = 0,
    offset: int = 0,
    fields: str = "",
) -> dict:
    """List all {{ tool.plural }}.

    Returns {{ tool.plural }} from the UniFi controller.
{% if tool.known_fields %}

    Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}

    Args:
        site: Site name (default: from env).
        limit: Max records to return (0 = all).
        offset: Number of records to skip.
        fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "{{ tool.path }}", site=site or None)
    total = len(data)
    data, missing = _paginate_and_filter(data, limit, offset, fields)
    return _format_response(data, f"Found {total} {{ tool.plural }}", missing_fields=missing)

{% elif tool.is_crud %}

# --- {{ tool.singular | title }} CRUD ---

@mcp.tool()
async def unifi_list_{{ tool.plural }}(
    site: str = "",
    limit: int = 0,
    offset: int = 0,
    fields: str = "",
) -> dict:
    """List all {{ tool.plural }}.
{% if tool.writable_fields %}

    Key fields: {{ tool.writable_fields[:8] | map(attribute='description') | join(', ') }}
{% elif tool.known_fields %}

    Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}

    Args:
        site: Site name (default: from env).
        limit: Max records to return (0 = all).
        offset: Number of records to skip.
        fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "{{ tool.path }}", site=site or None)
    total = len(data)
    data, missing = _paginate_and_filter(data, limit, offset, fields)
    return _format_response(data, f"Found {total} {{ tool.plural }}", missing_fields=missing)


@mcp.tool()
async def unifi_get_{{ tool.singular }}(id: str, site: str = "") -> dict:
    """Get a single {{ tool.singular }} by ID.

    Args:
        id: The _id of the {{ tool.singular }}.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    data = await client.request("GET", "{{ tool.path }}/{id}".format(id=id), site=site or None)
    if isinstance(data, list) and len(data) == 1:
        return _format_response(data[0])
    return _format_response(data)

if not UNIFI_READ_ONLY:
{% filter indent(4, first=True) %}

@mcp.tool()
async def unifi_create_{{ tool.singular }}(
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Create a new {{ tool.singular }}.

    Args:
        data: {{ tool.singular | title }} configuration.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% elif tool.required_create_fields %}
            {{ tool.required_create_fields }}
{% elif tool.known_fields %}
            Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).
{% if tool.workflow_hint %}

    {{ tool.workflow_hint }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "create_{{ tool.singular }}", "data": data},
            "DRY RUN (POST {{ tool.path }}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("POST", "{{ tool.path }}", json_data=data, site=site or None)
    return _format_response(result, "Created {{ tool.singular }}")


@mcp.tool()
async def unifi_update_{{ tool.singular }}(
    id: str,
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Update an existing {{ tool.singular }}.

    Args:
        id: The _id of the {{ tool.singular }} to update.
        data: Fields to update.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% elif tool.known_fields %}
            Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).
{% if tool.full_object_update %}

    Note: This resource requires sending the FULL object on update, not just changed fields.
    First GET the current object, modify the fields you want, then send the complete object.
{% endif %}
{% if tool.workflow_hint %}

    {{ tool.workflow_hint }}
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "update_{{ tool.singular }}", "id": id, "data": data},
            "DRY RUN (PUT {{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("PUT", "{{ tool.path }}/{id}".format(id=id), json_data=data, site=site or None)
    return _format_response(result, "Updated {{ tool.singular }}")

{% if not tool.no_rest_delete %}

@mcp.tool()
async def unifi_delete_{{ tool.singular }}(
    id: str,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Delete a {{ tool.singular }}.

    Args:
        id: The _id of the {{ tool.singular }} to delete.
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "delete_{{ tool.singular }}", "id": id},
            "DRY RUN (DELETE {{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    result = await client.request("DELETE", "{{ tool.path }}/{id}".format(id=id), site=site or None)
    return _format_response(result, "Deleted {{ tool.singular }}")

{% endif %}
{% endfilter %}
{% endif %}
{% endmacro %}
{% macro render_stat_tool(tool) %}
{% if tool.resource == "report" %}

@mcp.tool()
async def unifi_list_report(
    interval: str = "hourly",
    report_type: str = "site",
    site: str = "",
    limit: int = 0,
    offset: int = 0,
    fields: str = "",
) -> dict:
    """Get statistical reports.

    Args:
        interval: Report interval: '5minutes', 'hourly', or 'daily'.
        report_type: Report type: 'site', 'user', 'ap'.
        site: Site name (default: from env).
        limit: Max records to return (0 = all).
        offset: Number of records to skip.
        fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

    Note: {{ tool.note }}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    path = f"stat/report/{interval}.{report_type}"
    data = await client.request("POST", path, json_data={}, site=site or None)
    total = len(data)
    data, missing = _paginate_and_filter(data, limit, offset, fields)
    return _format_response(data, f"Found {total} report records", missing_fields=missing)

{% else %}

@mcp.tool()
async def unifi_list_{{ tool.display_name }}(
    site: str = "",
    limit: int = 0,
    offset: int = 0,
    fields: str = "",
) -> dict:
    """List {{ tool.display_name }} statistics.
{% if tool.note %}

    Note: {{ tool.note }}
{% endif %}
{% if tool.sample_fields %}

    Key fields: {{ tool.sample_fields | join(', ') }}
{% elif tool.known_fields %}

    Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}

    Args:
        site: Site name (default: from env).
        limit: Max records to return (0 = all).
        offset: Number of records to skip.
        fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
{% if tool.method == "POST" %}
    data = await client.request("POST", "{{ tool.path }}", json_data={{ tool.post_body }}, site=site or None)
{% else %}
    data = await client.request("GET", "{{ tool.path }}", site=site or None)
{% endif %}
    total = len(data)
    data, missing = _paginate_and_filter(data, limit, offset, fields)
    return _format_response(data, f"Found {total} {{ tool.display_name }} records", missing_fields=missing)

{% endif %}
{% endmacro %}
{% macro _render_cmd_body(tool) %}

@mcp.tool()
async def unifi_{{ tool.tool_name }}(
{% for pname, ptype in tool.params.items() %}
{% if pname == "site" %}
    target_site: {{ ptype }},
{% else %}
    {{ pname }}: {{ ptype }},
{% endif %}
{% endfor %}
{% if tool.is_mutation %}
    confirm: bool = False,
{% endif %}
    site: str = "",
) -> dict:
    """Execute '{{ tool.command }}' via {{ tool.manager }}.

{% for pname, ptype in tool.params.items() %}
    Args:
{% if pname == "site" %}
        target_site: Target site for the command ({{ ptype }}).
{% else %}
        {{ pname }}: {{ pname }} parameter ({{ ptype }}).
{% endif %}
{% endfor %}
{% if tool.is_mutation %}
        confirm: Must be True to execute. Returns preview if False.
{% endif %}
        site: Site name override (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
{% if tool.is_mutation %}
    if not confirm:
        preview = {"action": "{{ tool.tool_name }}", "cmd": "{{ tool.command }}"}
{% for pname, ptype in tool.params.items() %}
{% if pname == "site" %}
        preview["site"] = target_site
{% else %}
        preview["{{ pname }}"] = {{ pname }}
{% endif %}
{% endfor %}
        return _format_response(
            preview,
            "DRY RUN (POST {{ tool.path }}): Set confirm=True to execute.",
        )
{% endif %}
{% if "mac" in tool.params %}
    mac_err = _validate_mac(mac)
    if mac_err:
        return _format_response({"error": mac_err}, mac_err)
{% endif %}
    payload: dict[str, Any] = {"cmd": "{{ tool.command }}"}
{% for pname, ptype in tool.params.items() %}
{% if pname == "site" %}
    payload["site"] = target_site
{% else %}
    payload["{{ pname }}"] = {{ pname }}
{% endif %}
{% endfor %}
    client = await _get_client()
    result = await client.request("POST", "{{ tool.path }}", json_data=payload, site=site or None)
    return _format_response(result, "Executed {{ tool.command }}")
{% endmacro %}
{% macro render_cmd_tool(tool) %}
{% if tool.is_mutation %}

if not UNIFI_READ_ONLY:
{% filter indent(4, first=True) %}
{{ _render_cmd_body(tool) }}
{% endfilter %}
{% else %}
{{ _render_cmd_body(tool) }}
{% endif %}
{% endmacro %}
{% macro render_v2_tool(tool) %}

# --- v2: {{ tool.singular | title }} ---
{% if "GET" in tool.methods %}

@mcp.tool()
async def unifi_list_{{ tool.plural }}(
    site: str = "",
    limit: int = 0,
    offset: int = 0,
    fields: str = "",
) -> dict:
    """List all {{ tool.plural }} (v2 API).
{% if tool.writable_fields %}

    Key fields: {{ tool.writable_fields[:8] | map(attribute='description') | join(', ') }}
{% elif tool.known_fields %}

    Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}

    Args:
        site: Site name (default: from env).
        limit: Max records to return (0 = all).
        offset: Number of records to skip.
        fields: Comma-separated field names to include (e.g. 'name,mac'). Always includes _id.

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    data = await client.request("GET", "/{{ tool.path }}".replace("{site}", effective_site))
    if isinstance(data, list):
        total = len(data)
        data, missing = _paginate_and_filter(data, limit, offset, fields)
        return _format_response(data, f"Found {total} {{ tool.plural }}", missing_fields=missing)
    return _format_response(data)

{% endif %}
{% if "POST" in tool.methods or "PUT" in tool.methods or "DELETE" in tool.methods %}

if not UNIFI_READ_ONLY:
{% filter indent(4, first=True) %}
{% if "POST" in tool.methods %}

@mcp.tool()
async def unifi_create_{{ tool.singular }}(
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Create a new {{ tool.singular }} (v2 API).

    Args:
        data: {{ tool.singular | title }} configuration.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% elif tool.create_hint %}
            {{ tool.create_hint }}
{% elif tool.known_fields %}
            Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "create_{{ tool.singular }}", "data": data},
            "DRY RUN (POST /{{ tool.path }}): Set confirm=True to execute.",
        )
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    result = await client.request("POST", "/{{ tool.path }}".replace("{site}", effective_site), json_data=data)
    return _format_response(result, "Created {{ tool.singular }}")

{% endif %}
{% if "PUT" in tool.methods %}

@mcp.tool()
async def unifi_update_{{ tool.singular }}(
    id: str,
    data: dict,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Update a {{ tool.singular }} (v2 API).

    Args:
        id: The ID of the {{ tool.singular }} to update.
        data: The FULL {{ tool.singular }} object with your changes applied.
            v2 API requires sending the complete object, not just changed fields.
            First GET the current object, modify the fields you want, then send the full object.
{% if tool.writable_fields %}
            Fields: {{ tool.writable_fields[:10] | map(attribute='description') | join(', ') }}
{% elif tool.known_fields %}
            Known fields: {{ tool.known_fields | join(', ') }}
{% endif %}
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "update_{{ tool.singular }}", "id": id, "data": data},
            "DRY RUN (PUT /{{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    result = await client.request("PUT", "/{{ tool.path }}/{id}".replace("{site}", effective_site).format(id=id), json_data=data)
    return _format_response(result, "Updated {{ tool.singular }}")

{% endif %}
{% if "DELETE" in tool.methods %}

@mcp.tool()
async def unifi_delete_{{ tool.singular }}(
    id: str,
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Delete a {{ tool.singular }} (v2 API).

    Args:
        id: The ID of the {{ tool.singular }} to delete.
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    if not confirm:
        return _format_response(
            {"action": "delete_{{ tool.singular }}", "id": id},
            "DRY RUN (DELETE /{{ tool.path }}/{id}): Set confirm=True to execute.",
        )
    client = await _get_client()
    effective_site = site or UNIFI_SITE
    result = await client.request("DELETE", "/{{ tool.path }}/{id}".replace("{site}", effective_site).format(id=id))
    return _format_response(result, "Deleted {{ tool.singular }}")

{% endif %}
{% endfilter %}
{% endif %}
{% endmacro %}

{% for mod in module_order %}
{% set mod_rest = rest_by_module.get(mod, []) %}
{% set mod_stat = stat_by_module.get(mod, []) %}
{% set mod_cmd = cmd_by_module.get(mod, []) %}
{% set mod_v2 = v2_by_module.get(mod, []) %}
{% if mod_rest or mod_stat or mod_cmd or mod == "device" %}

if "{{ mod }}" in UNIFI_MODULES or "v1" in UNIFI_MODULES:
{% filter indent(4, first=True) %}
# ===========================================================================
# Module: {{ mod }}
# ===========================================================================
{% for tool in mod_rest %}
{{ render_rest_tool(tool) }}
{% endfor %}
{% for tool in mod_stat %}
{{ render_stat_tool(tool) }}
{% endfor %}
{% for tool in mod_cmd %}
{{ render_cmd_tool(tool) }}
{% endfor %}
{% if mod == "device" %}

# ===========================================================================
# Special: Port Override Helper
# ===========================================================================

if not UNIFI_READ_ONLY:
{% filter indent(4, first=True) %}
@mcp.tool()
async def unifi_set_port_override(
    device_id: str,
    port_idx: int,
    portconf_id: str = "",
    name: str = "",
    native_networkconf_id: str = "",
    forward: str = "",
    poe_mode: str = "",
    confirm: bool = False,
    site: str = "",
) -> dict:
    """Set port override on a device (switch port configuration).

    This updates a specific port on a UniFi switch device.

    Args:
        device_id: The _id of the device.
        port_idx: Port number (1-based).
        portconf_id: Port profile ID to apply (from rest/portconf).
        name: Custom port name.
        native_networkconf_id: Network ID for native VLAN.
        forward: Forward mode ('all', 'customize', 'disabled').
        poe_mode: PoE mode ('auto', 'off', 'pasv24', 'passthrough').
        confirm: Must be True to execute. Returns preview if False.
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    override: dict[str, Any] = {"port_idx": port_idx}
    if portconf_id:
        override["portconf_id"] = portconf_id
    if name:
        override["name"] = name
    if native_networkconf_id:
        override["native_networkconf_id"] = native_networkconf_id
    if forward:
        override["forward"] = forward
    if poe_mode:
        override["poe_mode"] = poe_mode

    if not confirm:
        return _format_response(
            {"action": "set_port_override", "device_id": device_id, "override": override},
            "DRY RUN (PUT rest/device/{device_id}): Set confirm=True to execute.",
        )

    client = await _get_client()
    # First get current device to preserve existing overrides
    device_data = await client.request("GET", f"rest/device/{device_id}", site=site or None)
    if isinstance(device_data, list) and device_data:
        device_data = device_data[0]

    existing_overrides = []
    if isinstance(device_data, dict):
        existing_overrides = device_data.get("port_overrides", [])

    # Replace or append override for this port_idx
    new_overrides = [o for o in existing_overrides if o.get("port_idx") != port_idx]
    new_overrides.append(override)

    result = await client.request(
        "PUT",
        f"rest/device/{device_id}",
        json_data={"port_overrides": new_overrides},
        site=site or None,
    )
    return _format_response(result, f"Set port override on port {port_idx}")
{% endfilter %}

{% endif %}
{% endfilter %}
{% endif %}
{% if mod_v2 %}

if "{{ mod }}" in UNIFI_MODULES or "v2" in UNIFI_MODULES:
{% filter indent(4, first=True) %}
{% for tool in mod_v2 %}
{{ render_v2_tool(tool) }}
{% endfor %}
{% endfilter %}
{% endif %}
{% endfor %}

# ===========================================================================
# Global Endpoint Tools (always-on)
# ===========================================================================
{% for tool in global_tools %}
{% if tool.is_mutating %}

if not UNIFI_READ_ONLY:
{% filter indent(4, first=True) %}
@mcp.tool()
async def unifi_{{ tool.name }}({{ 'site: str = ""' if '{site}' in tool.path else '' }}) -> dict:
    """{{ tool.name | replace('_', ' ') | title }}.
{% if not tool.auth %}

    No authentication required.
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
{% if tool.auth %}
    client = await _get_client()
    data = await client.request("{{ tool.method }}", "{{ tool.path }}")
{% else %}
    # No auth required
    async with httpx.AsyncClient(
        base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
        verify=UNIFI_VERIFY_SSL,
        timeout=30.0,
    ) as c:
        resp = await c.request("{{ tool.method }}", "{{ tool.path }}")
        resp.raise_for_status()
        data = resp.json()
{% endif %}
    return _format_response(data)
{% endfilter %}
{% else %}

@mcp.tool()
async def unifi_{{ tool.name }}({{ 'site: str = ""' if '{site}' in tool.path else '' }}) -> dict:
    """{{ tool.name | replace('_', ' ') | title }}.
{% if not tool.auth %}

    No authentication required.
{% endif %}

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
{% if tool.auth %}
    client = await _get_client()
    data = await client.request("{{ tool.method }}", "{{ tool.path }}")
{% else %}
    # No auth required
    async with httpx.AsyncClient(
        base_url=f"https://{UNIFI_HOST}:{UNIFI_PORT}",
        verify=UNIFI_VERIFY_SSL,
        timeout=30.0,
    ) as c:
        resp = await c.request("{{ tool.method }}", "{{ tool.path }}")
        resp.raise_for_status()
        data = resp.json()
{% endif %}
    return _format_response(data)

{% endif %}
{% endfor %}

# ===========================================================================
# Network Overview Tool (always-on, read-only)
# ===========================================================================


@mcp.tool()
async def unifi_get_overview(site: str = "") -> dict:
    """Get a concise network overview in a single call.

    Returns controller version, health status, device/network/WLAN summaries,
    client count, and active alarm count. Use this as a starting point before
    calling detailed tools.

    Args:
        site: Site name (default: from env).

    If this tool returns an unexpected error, call unifi_report_issue to report it.
    """
    client = await _get_client()
    s = site or UNIFI_SITE

    health = await client.request("GET", "stat/health", site=s)
    devices = await client.request("GET", "stat/device", site=s)
    networks = await client.request("GET", "rest/networkconf", site=s)
    wlans = await client.request("GET", "rest/wlanconf", site=s)
    clients = await client.request("GET", "stat/sta", site=s)
    alarms = await client.request("GET", "stat/alarm", site=s)
    sysinfo = await client.request("GET", "stat/sysinfo", site=s)

    version = ""
    if sysinfo and isinstance(sysinfo, list) and sysinfo[0]:
        version = sysinfo[0].get("version", "")

    overview = {
        "controller_version": version,
        "health": {
            h.get("subsystem", "?"): h.get("status", "?")
            for h in health if isinstance(h, dict)
        },
        "device_summary": [
            {
                "name": d.get("name", ""),
                "type": d.get("type", ""),
                "model": d.get("model", ""),
                "mac": d.get("mac", ""),
                "status": "connected" if d.get("state") == 1 else "disconnected",
                "ip": d.get("ip", ""),
            }
            for d in devices if isinstance(d, dict)
        ],
        "network_summary": [
            {
                "name": n.get("name", ""),
                "purpose": n.get("purpose", ""),
                "subnet": n.get("ip_subnet", ""),
                "vlan": n.get("vlan", None),
                "enabled": n.get("enabled", True),
            }
            for n in networks if isinstance(n, dict)
        ],
        "wlan_summary": [
            {
                "name": w.get("name", ""),
                "security": w.get("security", ""),
                "enabled": w.get("enabled", True),
                "wpa_mode": w.get("wpa_mode", ""),
            }
            for w in wlans if isinstance(w, dict)
        ],
        "total_clients": len(clients) if isinstance(clients, list) else 0,
        "active_alarms": len([
            a for a in alarms
            if isinstance(a, dict) and not a.get("archived")
        ]) if isinstance(alarms, list) else 0,
    }
    return _format_response(overview, "Network overview")


# ===========================================================================
# Tool Search (always-on, read-only)
# ===========================================================================

_TOOL_INDEX = {{ tool_index | tojson }}


@mcp.tool()
async def unifi_search_tools(query: str) -> dict:
    """Search for UniFi MCP tools by keyword.

    Returns matching tool names with descriptions. Use this to discover which
    tools are available for a task instead of scanning all tool signatures.

    Examples: "vlan", "firewall", "client wifi", "switch port", "backup"

    Args:
        query: Search terms (e.g. "wifi clients", "firewall rules", "port").
              Multiple words require all to match (AND logic).
    """
    terms = query.lower().split()
    if not terms:
        return _format_response([], "No search terms provided")
    matches = [entry for entry in _TOOL_INDEX if all(t in entry["keywords"] for t in terms)]
    results = [{"tool": m["name"], "description": m["description"], "module": m["module"]} for m in matches]
    return _format_response(results, f"Tools matching '{query}'")


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    mcp.run()
