"""Integration tests for REST {{ tool.singular }} endpoint (auto-generated).

DO NOT EDIT THIS FILE. All changes must be made in the generator.
"""

from __future__ import annotations

import time
import uuid

import httpx
import pytest
{% if tool.is_setting %}


class TestSettings:
    """Tests for the settings resource."""

    def test_list_settings(self, authenticated_client):
        """Verify listing all settings returns 200 + valid data."""
        data = authenticated_client.api_get("rest/setting")
        assert isinstance(data, list)
        # Settings should have at least a few categories
        assert len(data) > 0

    def test_settings_have_key_field(self, authenticated_client):
        """Every setting record should have a 'key' field."""
        data = authenticated_client.api_get("rest/setting")
        for item in data:
            assert "key" in item, f"Setting missing 'key' field: {item.get('_id')}"
            assert "_id" in item

    def test_get_setting_by_key(self, authenticated_client):
        """Can retrieve a specific setting by key."""
        data = authenticated_client.api_get("rest/setting")
        if not data:
            pytest.skip("No settings available")
        first_key = data[0]["key"]
        # Re-fetch and filter
        all_settings = authenticated_client.api_get("rest/setting")
        found = [s for s in all_settings if s.get("key") == first_key]
        assert len(found) == 1
        assert found[0]["key"] == first_key
{% elif tool.is_readonly %}


class TestReadOnly{{ tool.singular | title | replace('_', '') }}:
    """Tests for the read-only {{ tool.singular }} resource."""

    def test_list_{{ tool.plural }}(self, authenticated_client):
        """Verify listing {{ tool.plural }} returns valid data."""
        data = authenticated_client.api_get("{{ tool.path }}")
        assert isinstance(data, list)
{% else %}


class Test{{ tool.singular | title | replace('_', '') }}CRUD:
    """Full CRUD lifecycle tests for {{ tool.singular }}."""

    def test_list_{{ tool.plural }}(self, authenticated_client):
        """Verify listing {{ tool.plural }} returns 200 + valid data."""
        data = authenticated_client.api_get("{{ tool.path }}")
        assert isinstance(data, list)

{% if tool.create_payload %}
    def test_crud_lifecycle(self, authenticated_client{{ ', default_network_id' if tool.needs_network_id else '' }}):
        """Create → Read → Update → Delete lifecycle test."""
        unique = uuid.uuid4().hex[:8]

        # --- Create ---
        create_data = {{ tool.create_payload_rendered }}
        try:
            result = authenticated_client.api_post("{{ tool.path }}", create_data)
        except (httpx.HTTPStatusError, RuntimeError) as e:
            pytest.skip(f"Create {{ tool.singular }} not supported in test env: {e}")
        assert isinstance(result, list) and len(result) > 0
        created = result[0]
        resource_id = created["_id"]
        assert resource_id

        try:
            # --- Read back ---
            all_items = authenticated_client.api_get("{{ tool.path }}")
            found = [i for i in all_items if i.get("_id") == resource_id]
            assert len(found) == 1, f"Created {{ tool.singular }} not found in list"

            # --- Update ---
{% if tool.update_field %}
            update_data = {"{{ tool.update_field }}": {{ tool.update_value }}}
            updated = authenticated_client.api_put(f"{{ tool.path }}/{resource_id}", update_data)
            assert isinstance(updated, list)
{% endif %}

        finally:
            # --- Delete (cleanup) ---
            authenticated_client.api_delete(f"{{ tool.path }}/{resource_id}")

        # --- Verify gone ---
        time.sleep(0.5)
        all_items = authenticated_client.api_get("{{ tool.path }}")
        found = [i for i in all_items if i.get("_id") == resource_id]
        assert len(found) == 0, "{{ tool.singular }} was not deleted"
{% endif %}
{% endif %}
