"""Integration tests for REST {{ tool.singular }} endpoint (auto-generated).

DO NOT EDIT THIS FILE. All changes must be made in the generator.
"""

from __future__ import annotations

import time
import uuid

import httpx
import pytest
{% if tool.is_setting %}


class TestSettings:
    """Tests for the settings resource."""

    def test_list_settings(self, authenticated_client):
        """Verify listing all settings returns 200 + valid data."""
        data = authenticated_client.api_get("rest/setting")
        assert isinstance(data, list)
        # Settings should have at least a few categories
        assert len(data) > 0

    def test_settings_have_key_field(self, authenticated_client):
        """Every setting record should have a 'key' field."""
        data = authenticated_client.api_get("rest/setting")
        for item in data:
            assert "key" in item, f"Setting missing 'key' field: {item.get('_id')}"
            assert "_id" in item

    def test_get_setting_by_key(self, authenticated_client):
        """Can retrieve a specific setting by key."""
        data = authenticated_client.api_get("rest/setting")
        if not data:
            pytest.skip("No settings available")
        first_key = data[0]["key"]
        # Re-fetch and filter
        all_settings = authenticated_client.api_get("rest/setting")
        found = [s for s in all_settings if s.get("key") == first_key]
        assert len(found) == 1
        assert found[0]["key"] == first_key
{% elif tool.is_hardware_dependent %}


class Test{{ tool.singular | title | replace('_', '') }}HardwareDependent:
    """Tests for {{ tool.singular }} — requires hardware for full CRUD."""

    def test_list_{{ tool.plural }}(self, authenticated_client):
        """Verify listing {{ tool.plural }} returns 200 or 400 (needs hardware)."""
        resp = authenticated_client.client.get(
            f"/api/s/{authenticated_client.site}/{{ tool.path }}",
            headers=authenticated_client._headers(),
        )
        # Without hardware: 400 (InvalidObject/needs device) or 404 (needs
        # device _id suffix, e.g. rest/device) are expected.
        # 200 means hardware exists — also fine.
        assert resp.status_code in (200, 400, 404), (
            f"Unexpected status {resp.status_code} from {{ tool.path }}"
        )
        if resp.status_code == 200:
            data = resp.json()
            if isinstance(data, dict) and "data" in data:
                assert isinstance(data["data"], list)

{% if tool.create_payload %}
    def test_create_validates_input(self, authenticated_client{{ ', default_network_id' if tool.needs_network_id else '' }}):
        """Verify create endpoint exists and validates input correctly.

        Without physical hardware (gateway/AP), full CRUD is not possible.
        Instead we verify the endpoint is reachable and returns an expected
        error, proving the API surface works.
        """
        unique = uuid.uuid4().hex[:8]
        create_data = {{ tool.create_payload_rendered }}

        # Send request directly to inspect the response
        resp = authenticated_client.client.post(
            f"/api/s/{authenticated_client.site}/{{ tool.path }}",
            json=create_data,
            headers=authenticated_client._headers(),
        )
        # Without hardware: 400 (validation error) or 500 (no gateway) are expected.
        # 200 means hardware exists and create succeeded — also fine.
        assert resp.status_code in (200, 400, 500), (
            f"Unexpected status {resp.status_code} from {{ tool.path }} create"
        )
        if resp.status_code == 200:
            # Clean up if it unexpectedly succeeded
            body = resp.json()
            if isinstance(body, dict) and body.get("data"):
                resource_id = body["data"][0].get("_id")
                if resource_id:
                    authenticated_client.api_delete(f"{{ tool.path }}/{resource_id}")
{% endif %}
{% elif tool.is_readonly %}


class TestReadOnly{{ tool.singular | title | replace('_', '') }}:
    """Tests for the read-only {{ tool.singular }} resource."""

    def test_list_{{ tool.plural }}(self, authenticated_client):
        """Verify listing {{ tool.plural }} returns valid data."""
        data = authenticated_client.api_get("{{ tool.path }}")
        assert isinstance(data, list)
{% else %}


class Test{{ tool.singular | title | replace('_', '') }}CRUD:
    """Full CRUD lifecycle tests for {{ tool.singular }}."""

    def test_list_{{ tool.plural }}(self, authenticated_client):
        """Verify listing {{ tool.plural }} returns 200 + valid data."""
        data = authenticated_client.api_get("{{ tool.path }}")
        assert isinstance(data, list)

{% if tool.create_payload %}
    def test_crud_lifecycle(self, authenticated_client{{ ', default_network_id' if tool.needs_network_id else '' }}):
        """Create → Read → Update → Delete lifecycle test."""
        unique = uuid.uuid4().hex[:8]

        # --- Create ---
        create_data = {{ tool.create_payload_rendered }}
        try:
            result = authenticated_client.api_post("{{ tool.path }}", create_data)
        except (httpx.HTTPStatusError, RuntimeError) as e:
            pytest.skip(f"Create {{ tool.singular }} not supported in test env: {e}")
        assert isinstance(result, list) and len(result) > 0
        created = result[0]
        resource_id = created["_id"]
        assert resource_id

        try:
            # --- Read back ---
            all_items = authenticated_client.api_get("{{ tool.path }}")
            found = [i for i in all_items if i.get("_id") == resource_id]
            assert len(found) == 1, f"Created {{ tool.singular }} not found in list"

            # --- Update ---
{% if tool.update_field %}
            update_data = {"{{ tool.update_field }}": {{ tool.update_value }}}
            updated = authenticated_client.api_put(f"{{ tool.path }}/{resource_id}", update_data)
            assert isinstance(updated, list)
{% endif %}

        finally:
            # --- Delete (cleanup) ---
            authenticated_client.api_delete(f"{{ tool.path }}/{resource_id}")

        # --- Verify gone ---
        time.sleep(0.5)
        all_items = authenticated_client.api_get("{{ tool.path }}")
        found = [i for i in all_items if i.get("_id") == resource_id]
        assert len(found) == 0, "{{ tool.singular }} was not deleted"
{% endif %}
{% endif %}
